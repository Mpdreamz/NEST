:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/current

:github: https://github.com/elastic/elasticsearch-net

:imagesdir: ../../../images

== Filters Aggregation

Defines a multi bucket aggregations where each bucket is associated with a filter. 
Each bucket will collect all documents that match its associated filter. For documents
that do not match any filter, these will be collected in the _other bucket_.

Be sure to read {ref_current}/search-aggregations-bucket-filters-aggregation.html[the Elasticsearch documentation on Filters Aggregation].

== Named filters 

[source,javascript,method="expectjson"]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "other_bucket_key": "other_states_of_being",
        "filters": {
          "belly_up": {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          "stable": {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          "very_active": {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        }
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("projects_by_state", agg => agg
		.OtherBucket()
		.OtherBucketKey("other_states_of_being")
		.NamedFilters(filters => filters
			.Filter("belly_up", f => f.Term(p => p.State, StateOfBeing.BellyUp))
			.Filter("stable", f => f.Term(p => p.State, StateOfBeing.Stable))
			.Filter("very_active", f => f.Term(p => p.State, StateOfBeing.VeryActive))
		)
		.Aggregations(childAggs => childAggs
			.Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("projects_by_state")
	{
		OtherBucket = true,
		OtherBucketKey = "other_states_of_being",
		Filters = new NamedFiltersContainer
		{
				{ "belly_up", Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) },
				{ "stable", Query<Project>.Term(p=>p.State, StateOfBeing.Stable) },
				{ "very_active", Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive) }
		},
		Aggregations =
			new TermsAggregation("project_tags") { Field = Field<Project>(p => p.CuratedTags.First().Name) }
	}
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. [Be sure to read more about `.Agg` vs `.Aggregations` on the response here]()

[source,csharp,method="expectresponse"]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var namedResult = filterAgg.NamedBucket("belly_up");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("stable");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("very_active");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("other_states_of_being");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().Be(0);
----

== Anonymous filters 

[source,javascript,method="expectjson"]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "filters": [
          {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        ]
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("projects_by_state", agg => agg
		.OtherBucket()
		.AnonymousFilters(
			f => f.Term(p => p.State, StateOfBeing.BellyUp),
			f => f.Term(p => p.State, StateOfBeing.Stable),
			f => f.Term(p => p.State, StateOfBeing.VeryActive)
		)
		.Aggregations(childAggs => childAggs
			.Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("projects_by_state")
	{
		OtherBucket = true,
		Filters = new List<QueryContainer>
		{
			Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) ,
			Query<Project>.Term(p=>p.State, StateOfBeing.Stable) ,
			Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive)
		},
		Aggregations =
			new TermsAggregation("project_tags")
			{
				Field = Field<Project>(p => p.CuratedTags.First().Name)
			}
	}
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. [Be sure to read more about `.Agg` vs `.Aggregations` on the response here]()

[source,csharp,method="expectresponse"]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var results = filterAgg.AnonymousBuckets();
results.Count.Should().Be(4);
singleBucket.DocCount.Should().BeGreaterThan(0);
----

The last bucket is the _other bucket_ 

=== Handling Responses

[source,csharp,method="expectresponse"]
----
results.Last().DocCount.Should().Be(0);
----

== Empty Filters 

[source,javascript,method="expectjson"]
.Example json output
----
{
  "aggs": {
    "empty_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("empty_filters", agg => agg
		.AnonymousFilters()
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("empty_filters")
	{
		Filters = new List<QueryContainer>()
	}
}
----

=== Handling Responses

[source,csharp,method="expectresponse"]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("empty_filters").Buckets.Should().BeEmpty();
----

== Conditionless Filters 

[source,javascript,method="expectjson"]
.Example json output
----
{
  "aggs": {
    "conditionless_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("conditionless_filters", agg => agg
		.AnonymousFilters(
			q => new QueryContainer()
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("conditionless_filters")
	{
		Filters = new List<QueryContainer>
		{
			new QueryContainer()
		}
	}
}
----

=== Handling Responses

[source,csharp,method="expectresponse"]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("conditionless_filters").Buckets.Should().BeEmpty();
----

