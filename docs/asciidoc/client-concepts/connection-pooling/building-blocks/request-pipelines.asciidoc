:section-number: 4.2

:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/current

:github: https://github.com/elastic/elasticsearch-net

:imagesdir: ../../../images

== Request Pipeline

Every request is executed in the context of a `RequestPipeline` when using the 
default `ITransport` implementation.

[source,csharp,method="requestpipeline"]
----
var settings = TestClient.CreateSettings();
----

When calling Request/RequestAsync on Transport the whole coordination of the request is deferred to a new instance in a `using` block. 

[source,csharp,method="requestpipeline"]
----
var pipeline = new RequestPipeline(settings, DateTimeProvider.Default, new MemoryStreamFactory(), new SearchRequestParameters());

pipeline.GetType().Should().Implement<IDisposable>();
----

However the transport does not instantiate `RequestPipeline` directly; it uses a pluggable `IRequestPipelineFactory`
to create it

[source,csharp,method="requestpipeline"]
----
var requestPipelineFactory = new RequestPipelineFactory();

var requestPipeline = requestPipelineFactory.Create(
	settings, 
	DateTimeProvider.Default, //<1>
	new MemoryStreamFactory(), 
	new SearchRequestParameters());
requestPipeline.Should().BeOfType<RequestPipeline>();
requestPipeline.GetType().Should().Implement<IDisposable>();
----
<1> An <<date-time-providers,`IDateTimeProvider` implementation>>

you can pass your own `IRequestPipeline` implementation to the transport when instantiating a client 
allowing you to have requests executed on your own custom request pipeline

[source,csharp,method="requestpipeline"]
----
var transport = new Transport<ConnectionSettings>(settings, requestPipelineFactory, DateTimeProvider.Default, new MemoryStreamFactory());
----

[source,csharp,method="createpipeline"]
----
var pool = setupPool(new[] { TestClient.CreateNode(), TestClient.CreateNode(9201) });

var settings = new ConnectionSettings(pool, TestClient.CreateConnection());

settings = settingsSelector?.Invoke(settings) ?? settings;
----

[source,csharp,method="firstusagecheck"]
----
var singleNodePipeline = CreatePipeline(uris => new SingleNodeConnectionPool(uris.First()));

var staticPipeline = CreatePipeline(uris => new StaticConnectionPool(uris));

var sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris));
----

Here we have setup three pipelines using three different connection pools, lets see how they behave

[source,csharp,method="firstusagecheck"]
----
singleNodePipeline.FirstPoolUsageNeedsSniffing.Should().BeFalse();

staticPipeline.FirstPoolUsageNeedsSniffing.Should().BeFalse();

sniffingPipeline.FirstPoolUsageNeedsSniffing.Should().BeTrue();
----

Only the cluster that supports reseeding will opt in to FirstPoolUsageNeedsSniffing() 
You can however disable this on ConnectionSettings

[source,csharp,method="firstusagecheck"]
----
sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris), s => s.SniffOnStartup(false));

sniffingPipeline.FirstPoolUsageNeedsSniffing.Should().BeFalse();
----

[source,csharp,method="sniffsonconnectionfailure"]
----
var singleNodePipeline = CreatePipeline(uris => new SingleNodeConnectionPool(uris.First()));

var staticPipeline = CreatePipeline(uris => new StaticConnectionPool(uris));

var sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris));

singleNodePipeline.SniffsOnConnectionFailure.Should().BeFalse();

staticPipeline.SniffsOnConnectionFailure.Should().BeFalse();

sniffingPipeline.SniffsOnConnectionFailure.Should().BeTrue();
----

Only the cluster that supports reseeding will opt in to SniffsOnConnectionFailure() 
You can however disable this on ConnectionSettings

[source,csharp,method="sniffsonconnectionfailure"]
----
sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris), s => s.SniffOnConnectionFault(false));

sniffingPipeline.SniffsOnConnectionFailure.Should().BeFalse();
----

[source,csharp,method="sniffsonstalecluster"]
----
var dateTime = new TestableDateTimeProvider();

var singleNodePipeline = CreatePipeline(uris => new SingleNodeConnectionPool(uris.First(), dateTime), dateTimeProvider: dateTime);

var staticPipeline = CreatePipeline(uris => new StaticConnectionPool(uris, dateTimeProvider: dateTime), dateTimeProvider: dateTime);

var sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris, dateTimeProvider: dateTime), dateTimeProvider: dateTime);

singleNodePipeline.SniffsOnStaleCluster.Should().BeFalse();

staticPipeline.SniffsOnStaleCluster.Should().BeFalse();

sniffingPipeline.SniffsOnStaleCluster.Should().BeTrue();

singleNodePipeline.StaleClusterState.Should().BeFalse();

staticPipeline.StaleClusterState.Should().BeFalse();

sniffingPipeline.StaleClusterState.Should().BeFalse();
----

go one hour into the future 

[source,csharp,method="sniffsonstalecluster"]
----
dateTime.ChangeTime(d => d.Add(TimeSpan.FromHours(2)));
----

connection pools that do not support reseeding never go stale 

[source,csharp,method="sniffsonstalecluster"]
----
singleNodePipeline.StaleClusterState.Should().BeFalse();

staticPipeline.StaleClusterState.Should().BeFalse();
----

the sniffing connection pool supports reseeding so the pipeline will signal the state is out of date 

[source,csharp,method="sniffsonstalecluster"]
----
sniffingPipeline.StaleClusterState.Should().BeTrue();
----

A request pipeline also checks whether the overall time across multiple retries exceeds the request timeout.
See the <<respects-max-retry, max retry documentation>> for more details, here we assert that our request pipeline exposes this propertly

[source,csharp,method="istakingtoolong"]
----
var dateTime = new TestableDateTimeProvider();

var singleNodePipeline = CreatePipeline(uris => new SingleNodeConnectionPool(uris.First(), dateTime), dateTimeProvider: dateTime);

var staticPipeline = CreatePipeline(uris => new StaticConnectionPool(uris, dateTimeProvider: dateTime), dateTimeProvider: dateTime);

var sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris, dateTimeProvider: dateTime), dateTimeProvider: dateTime);

singleNodePipeline.IsTakingTooLong.Should().BeFalse();

staticPipeline.IsTakingTooLong.Should().BeFalse();

sniffingPipeline.IsTakingTooLong.Should().BeFalse();
----

go one hour into the future 

[source,csharp,method="istakingtoolong"]
----
dateTime.ChangeTime(d => d.Add(TimeSpan.FromHours(2)));
----

connection pools that do not support reseeding never go stale 

[source,csharp,method="istakingtoolong"]
----
singleNodePipeline.IsTakingTooLong.Should().BeTrue();

staticPipeline.IsTakingTooLong.Should().BeTrue();
----

the sniffing connection pool supports reseeding so the pipeline will signal the state is out of date 

[source,csharp,method="istakingtoolong"]
----
sniffingPipeline.IsTakingTooLong.Should().BeTrue();
----

request pipeline exposes the DateTime it started, here we assert it started 2 hours in the past 

[source,csharp,method="istakingtoolong"]
----
(dateTime.Now() - singleNodePipeline.StartedOn).Should().BePositive().And.BeCloseTo(TimeSpan.FromHours(2));

(dateTime.Now() - staticPipeline.StartedOn).Should().BePositive().And.BeCloseTo(TimeSpan.FromHours(2));

(dateTime.Now() - sniffingPipeline.StartedOn).Should().BePositive().And.BeCloseTo(TimeSpan.FromHours(2));
----

[source,csharp,method="setssniffpathusingtotimespan"]
----
var dateTime = new TestableDateTimeProvider();

var sniffingPipeline = CreatePipeline(uris => new SniffingConnectionPool(uris, dateTimeProvider: dateTime), dateTimeProvider: dateTime) as RequestPipeline;

sniffingPipeline.SniffPath.Should().Be("_nodes/_all/settings?flat_settings&timeout=2s");
----

