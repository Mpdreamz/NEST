using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;
///This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
///This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
///Generated of commit 

namespace Nest
{
	
	///<summary>descriptor for Bulk
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html
	///</pre>
	///</summary>
	public partial class BulkDescriptor
	{
		internal BulkQueryString _QueryString = new BulkQueryString(); 


		///<summary>Explicit write consistency setting for the operation</summary>
		public BulkDescriptor Consistency(ConsistencyOptions consistency)
		{
			this._QueryString.Consistency(consistency);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public BulkDescriptor Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Explicitely set the replication type</summary>
		public BulkDescriptor Replication(ReplicationOptions replication)
		{
			this._QueryString.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public BulkDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public BulkDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Default document type for items which don&#39;t provide one</summary>
		public BulkDescriptor TypeQueryString(string type)
		{
			this._QueryString.Type(type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatAliases
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html
	///</pre>
	///</summary>
	public partial class CatAliasesDescriptor
	{
		internal CatAliasesQueryString _QueryString = new CatAliasesQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAliasesDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAliasesDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatAliasesDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatAliasesDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatAliasesDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatAllocation
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html
	///</pre>
	///</summary>
	public partial class CatAllocationDescriptor
	{
		internal CatAllocationQueryString _QueryString = new CatAllocationQueryString(); 


		///<summary>The unit in which to display byte values</summary>
		public CatAllocationDescriptor Bytes(BytesOptions bytes)
		{
			this._QueryString.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAllocationDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAllocationDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatAllocationDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatAllocationDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatAllocationDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatCount
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html
	///</pre>
	///</summary>
	public partial class CatCountDescriptor
	{
		internal CatCountQueryString _QueryString = new CatCountQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatCountDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatCountDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatCountDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatCountDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatCountDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatHealth
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html
	///</pre>
	///</summary>
	public partial class CatHealthDescriptor
	{
		internal CatHealthQueryString _QueryString = new CatHealthQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatHealthDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatHealthDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatHealthDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatHealthDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Set to false to disable timestamping</summary>
		public CatHealthDescriptor Ts(bool ts = true)
		{
			this._QueryString.Ts(ts);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatHealthDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatHelp
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html
	///</pre>
	///</summary>
	public partial class CatHelpDescriptor
	{
		internal CatHelpQueryString _QueryString = new CatHelpQueryString(); 


		///<summary>Return help information</summary>
		public CatHelpDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatIndices
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html
	///</pre>
	///</summary>
	public partial class CatIndicesDescriptor
	{
		internal CatIndicesQueryString _QueryString = new CatIndicesQueryString(); 


		///<summary>The unit in which to display byte values</summary>
		public CatIndicesDescriptor Bytes(BytesOptions bytes)
		{
			this._QueryString.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatIndicesDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatIndicesDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatIndicesDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatIndicesDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Set to true to return stats only for primary shards</summary>
		public CatIndicesDescriptor Pri(bool pri = true)
		{
			this._QueryString.Pri(pri);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatIndicesDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatMaster
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html
	///</pre>
	///</summary>
	public partial class CatMasterDescriptor
	{
		internal CatMasterQueryString _QueryString = new CatMasterQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatMasterDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatMasterDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatMasterDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatMasterDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatMasterDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatNodes
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html
	///</pre>
	///</summary>
	public partial class CatNodesDescriptor
	{
		internal CatNodesQueryString _QueryString = new CatNodesQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodesDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodesDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatNodesDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatNodesDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatNodesDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatPendingTasks
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html
	///</pre>
	///</summary>
	public partial class CatPendingTasksDescriptor
	{
		internal CatPendingTasksQueryString _QueryString = new CatPendingTasksQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPendingTasksDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPendingTasksDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatPendingTasksDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatPendingTasksDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatPendingTasksDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatRecovery
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html
	///</pre>
	///</summary>
	public partial class CatRecoveryDescriptor
	{
		internal CatRecoveryQueryString _QueryString = new CatRecoveryQueryString(); 


		///<summary>The unit in which to display byte values</summary>
		public CatRecoveryDescriptor Bytes(BytesOptions bytes)
		{
			this._QueryString.Bytes(bytes);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatRecoveryDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRecoveryDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatRecoveryDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatRecoveryDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatRecoveryDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatShards
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html
	///</pre>
	///</summary>
	public partial class CatShardsDescriptor
	{
		internal CatShardsQueryString _QueryString = new CatShardsQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatShardsDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatShardsDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatShardsDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatShardsDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatShardsDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CatThreadPool
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html
	///</pre>
	///</summary>
	public partial class CatThreadPoolDescriptor
	{
		internal CatThreadPoolQueryString _QueryString = new CatThreadPoolQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatThreadPoolDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatThreadPoolDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Comma-separated list of column names to display</summary>
		public CatThreadPoolDescriptor H(params string[] h)
		{
			this._QueryString.H(h);
			return this;
		}
		

		///<summary>Return help information</summary>
		public CatThreadPoolDescriptor Help(bool help = true)
		{
			this._QueryString.Help(help);
			return this;
		}
		

		///<summary>Verbose mode. Display column headers</summary>
		public CatThreadPoolDescriptor V(bool v = true)
		{
			this._QueryString.V(v);
			return this;
		}
		

		///<summary>Enables displaying the complete node ids</summary>
		public CatThreadPoolDescriptor FullId(bool full_id = true)
		{
			this._QueryString.FullId(full_id);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClearScroll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html
	///</pre>
	///</summary>
	public partial class ClearScrollDescriptor
	{
		internal ClearScrollQueryString _QueryString = new ClearScrollQueryString(); 

		
	}
	
	
	///<summary>descriptor for ClusterGetSettings
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html
	///</pre>
	///</summary>
	public partial class ClusterGetSettingsDescriptor
	{
		internal ClusterGetSettingsQueryString _QueryString = new ClusterGetSettingsQueryString(); 


		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterGetSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterGetSettingsDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterGetSettingsDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterHealth
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html
	///</pre>
	///</summary>
	public partial class ClusterHealthDescriptor
	{
		internal ClusterHealthQueryString _QueryString = new ClusterHealthQueryString(); 


		///<summary>Specify the level of detail for returned information</summary>
		public ClusterHealthDescriptor Level(LevelOptions level)
		{
			this._QueryString.Level(level);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterHealthDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterHealthDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterHealthDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Wait until the specified number of shards is active</summary>
		public ClusterHealthDescriptor WaitForActiveShards(int wait_for_active_shards)
		{
			this._QueryString.WaitForActiveShards(wait_for_active_shards);
			return this;
		}
		

		///<summary>Wait until the specified number of nodes is available</summary>
		public ClusterHealthDescriptor WaitForNodes(string wait_for_nodes)
		{
			this._QueryString.WaitForNodes(wait_for_nodes);
			return this;
		}
		

		///<summary>Wait until the specified number of relocating shards is finished</summary>
		public ClusterHealthDescriptor WaitForRelocatingShards(int wait_for_relocating_shards)
		{
			this._QueryString.WaitForRelocatingShards(wait_for_relocating_shards);
			return this;
		}
		

		///<summary>Wait until cluster is in a specific state</summary>
		public ClusterHealthDescriptor WaitForStatus(WaitForStatusOptions wait_for_status)
		{
			this._QueryString.WaitForStatus(wait_for_status);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterPendingTasks
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html
	///</pre>
	///</summary>
	public partial class ClusterPendingTasksDescriptor
	{
		internal ClusterPendingTasksQueryString _QueryString = new ClusterPendingTasksQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterPendingTasksDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public ClusterPendingTasksDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterPutSettings
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html
	///</pre>
	///</summary>
	public partial class ClusterPutSettingsDescriptor
	{
		internal ClusterPutSettingsQueryString _QueryString = new ClusterPutSettingsQueryString(); 


		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterPutSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterReroute
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html
	///</pre>
	///</summary>
	public partial class ClusterRerouteDescriptor
	{
		internal ClusterRerouteQueryString _QueryString = new ClusterRerouteQueryString(); 


		///<summary>Simulate the operation only and return the resulting state</summary>
		public ClusterRerouteDescriptor DryRun(bool dry_run = true)
		{
			this._QueryString.DryRun(dry_run);
			return this;
		}
		

		///<summary>Don&#39;t return cluster state metadata (default: false)</summary>
		public ClusterRerouteDescriptor FilterMetadata(bool filter_metadata = true)
		{
			this._QueryString.FilterMetadata(filter_metadata);
			return this;
		}
		

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterRerouteDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public ClusterRerouteDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterState
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html
	///</pre>
	///</summary>
	public partial class ClusterStateDescriptor
	{
		internal ClusterStateQueryString _QueryString = new ClusterStateQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterStateDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public ClusterStateDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>A comma separated list to return specific index templates when returning metadata</summary>
		public ClusterStateDescriptor IndexTemplates(params string[] index_templates)
		{
			this._QueryString.IndexTemplates(index_templates);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStateDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ClusterStats
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html
	///</pre>
	///</summary>
	public partial class ClusterStatsDescriptor
	{
		internal ClusterStatsQueryString _QueryString = new ClusterStatsQueryString(); 


		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStatsDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public ClusterStatsDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Count
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html
	///</pre>
	///</summary>
	public partial class CountDescriptor<T>
	{
		internal CountQueryString _QueryString = new CountQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountDescriptor<T> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public CountDescriptor<T> MinScore(int min_score)
		{
			this._QueryString.MinScore(min_score);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountDescriptor<T> Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public CountDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public CountDescriptor<T> Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for CountPercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class CountPercolateDescriptor
	{
		internal CountPercolateQueryString _QueryString = new CountPercolateQueryString(); 


		///<summary>A comma-separated list of specific routing values</summary>
		public CountPercolateDescriptor Routing(params string[] routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountPercolateDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountPercolateDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountPercolateDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountPercolateDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The index to count percolate the document into. Defaults to index.</summary>
		public CountPercolateDescriptor PercolateIndex(string percolate_index)
		{
			this._QueryString.PercolateIndex(percolate_index);
			return this;
		}
		

		///<summary>The type to count percolate document into. Defaults to type.</summary>
		public CountPercolateDescriptor PercolateType(string percolate_type)
		{
			this._QueryString.PercolateType(percolate_type);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public CountPercolateDescriptor Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public CountPercolateDescriptor VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Delete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html
	///</pre>
	///</summary>
	public partial class DeleteDescriptor<T>
	{
		internal DeleteQueryString _QueryString = new DeleteQueryString(); 


		///<summary>Specific write consistency setting for the operation</summary>
		public DeleteDescriptor<T> Consistency(ConsistencyOptions consistency)
		{
			this._QueryString.Consistency(consistency);
			return this;
		}
		

		///<summary>ID of parent document</summary>
		public DeleteDescriptor<T> Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public DeleteDescriptor<T> Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public DeleteDescriptor<T> Replication(ReplicationOptions replication)
		{
			this._QueryString.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public DeleteDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public DeleteDescriptor<T> Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public DeleteDescriptor<T> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public DeleteDescriptor<T> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for DeleteByQuery
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html
	///</pre>
	///</summary>
	public partial class DeleteByQueryDescriptor<T>
	{
		internal DeleteByQueryQueryString _QueryString = new DeleteByQueryQueryString(); 


		///<summary>The analyzer to use for the query string</summary>
		public DeleteByQueryDescriptor<T> Analyzer(string analyzer)
		{
			this._QueryString.Analyzer(analyzer);
			return this;
		}
		

		///<summary>Specific write consistency setting for the operation</summary>
		public DeleteByQueryDescriptor<T> Consistency(ConsistencyOptions consistency)
		{
			this._QueryString.Consistency(consistency);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DeleteByQueryDescriptor<T> DefaultOperator(DefaultOperatorOptions default_operator)
		{
			this._QueryString.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public DeleteByQueryDescriptor<T> Df(string df)
		{
			this._QueryString.Df(df);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public DeleteByQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public DeleteByQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public DeleteByQueryDescriptor<T> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public DeleteByQueryDescriptor<T> Replication(ReplicationOptions replication)
		{
			this._QueryString.Replication(replication);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public DeleteByQueryDescriptor<T> Q(string q)
		{
			this._QueryString.Q(q);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public DeleteByQueryDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public DeleteByQueryDescriptor<T> Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public DeleteByQueryDescriptor<T> Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Exists
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class ExistsDescriptor
	{
		internal ExistsQueryString _QueryString = new ExistsQueryString(); 


		///<summary>The ID of the parent document</summary>
		public ExistsDescriptor Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExistsDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public ExistsDescriptor Realtime(bool realtime = true)
		{
			this._QueryString.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public ExistsDescriptor Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public ExistsDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for ExplainGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html
	///</pre>
	///</summary>
	public partial class ExplainDescriptor
	{
		internal ExplainQueryString _QueryString = new ExplainQueryString(); 


		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public ExplainDescriptor AnalyzeWildcard(bool analyze_wildcard = true)
		{
			this._QueryString.AnalyzeWildcard(analyze_wildcard);
			return this;
		}
		

		///<summary>The analyzer for the query string query</summary>
		public ExplainDescriptor Analyzer(string analyzer)
		{
			this._QueryString.Analyzer(analyzer);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public ExplainDescriptor DefaultOperator(DefaultOperatorOptions default_operator)
		{
			this._QueryString.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The default field for query string query (default: _all)</summary>
		public ExplainDescriptor Df(string df)
		{
			this._QueryString.Df(df);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ExplainDescriptor Lenient(bool lenient = true)
		{
			this._QueryString.Lenient(lenient);
			return this;
		}
		

		///<summary>Specify whether query terms should be lowercased</summary>
		public ExplainDescriptor LowercaseExpandedTerms(bool lowercase_expanded_terms = true)
		{
			this._QueryString.LowercaseExpandedTerms(lowercase_expanded_terms);
			return this;
		}
		

		///<summary>The ID of the parent document</summary>
		public ExplainDescriptor Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExplainDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public ExplainDescriptor Q(string q)
		{
			this._QueryString.Q(q);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public ExplainDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public ExplainDescriptor Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public ExplainDescriptor Source(params string[] _source)
		{
			this._QueryString.Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor SourceExclude(params string[] _source_exclude)
		{
			this._QueryString.SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor SourceExclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor SourceInclude(params string[] _source_include)
		{
			this._QueryString.SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor SourceInclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceInclude(typedPathLookups);
			return this;
		}
			
		
	}
	
	
	///<summary>descriptor for Get
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class GetDescriptor<T>
	{
		internal GetQueryString _QueryString = new GetQueryString(); 


		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>The ID of the parent document</summary>
		public GetDescriptor<T> Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public GetDescriptor<T> Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public GetDescriptor<T> Realtime(bool realtime = true)
		{
			this._QueryString.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public GetDescriptor<T> Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public GetDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public GetDescriptor<T> Source(params string[] _source)
		{
			this._QueryString.Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(params string[] _source_exclude)
		{
			this._QueryString.SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(params string[] _source_include)
		{
			this._QueryString.SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceInclude(typedPathLookups);
			return this;
		}
			

		///<summary>Explicit version number for concurrency control</summary>
		public GetDescriptor<T> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public GetDescriptor<T> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for GetSource
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html
	///</pre>
	///</summary>
	public partial class SourceDescriptor<T>
	{
		internal SourceQueryString _QueryString = new SourceQueryString(); 


		///<summary>The ID of the parent document</summary>
		public SourceDescriptor<T> Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceDescriptor<T> Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceDescriptor<T> Realtime(bool realtime = true)
		{
			this._QueryString.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceDescriptor<T> Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public SourceDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public SourceDescriptor<T> Source(params string[] _source)
		{
			this._QueryString.Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(params string[] _source_exclude)
		{
			this._QueryString.SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(params string[] _source_include)
		{
			this._QueryString.SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceInclude(typedPathLookups);
			return this;
		}
			

		///<summary>Explicit version number for concurrency control</summary>
		public SourceDescriptor<T> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public SourceDescriptor<T> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Index
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html
	///</pre>
	///</summary>
	public partial class IndexDescriptor<T>
	{
		internal IndexQueryString _QueryString = new IndexQueryString(); 


		///<summary>Explicit write consistency setting for the operation</summary>
		public IndexDescriptor<T> Consistency(ConsistencyOptions consistency)
		{
			this._QueryString.Consistency(consistency);
			return this;
		}
		

		///<summary>Explicit operation type</summary>
		public IndexDescriptor<T> OpType(OpTypeOptions op_type)
		{
			this._QueryString.OpType(op_type);
			return this;
		}
		

		///<summary>ID of the parent document</summary>
		public IndexDescriptor<T> Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public IndexDescriptor<T> Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public IndexDescriptor<T> Replication(ReplicationOptions replication)
		{
			this._QueryString.Replication(replication);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public IndexDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public IndexDescriptor<T> Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit timestamp for the document</summary>
		public IndexDescriptor<T> Timestamp(string timestamp)
		{
			this._QueryString.Timestamp(timestamp);
			return this;
		}
		

		///<summary>Expiration time for the document</summary>
		public IndexDescriptor<T> Ttl(string ttl)
		{
			this._QueryString.Ttl(ttl);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public IndexDescriptor<T> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public IndexDescriptor<T> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesAnalyzeGetForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html
	///</pre>
	///</summary>
	public partial class AnalyzeDescriptor
	{
		internal AnalyzeQueryString _QueryString = new AnalyzeQueryString(); 


		///<summary>The name of the analyzer to use</summary>
		public AnalyzeDescriptor Analyzer(string analyzer)
		{
			this._QueryString.Analyzer(analyzer);
			return this;
		}
		

		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field(string field)
		{
			this._QueryString.Field(field);
			return this;
		}
		
			
		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field<T>(Expression<Func<T, object>> typedPathLookup) where T : class
		{
			typedPathLookup.ThrowIfNull("typedPathLookup");
			this._QueryString._Field(typedPathLookup);
			return this;
		}
			

		///<summary>A comma-separated list of filters to use for the analysis</summary>
		public AnalyzeDescriptor Filters(params string[] filters)
		{
			this._QueryString.Filters(filters);
			return this;
		}
		

		///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor IndexQueryString(string index)
		{
			this._QueryString.Index(index);
			return this;
		}
		

		///<summary>With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)</summary>
		public AnalyzeDescriptor PreferLocal(bool prefer_local = true)
		{
			this._QueryString.PreferLocal(prefer_local);
			return this;
		}
		

		///<summary>The text on which the analysis should be performed (when request body is not used)</summary>
		public AnalyzeDescriptor Text(string text)
		{
			this._QueryString.Text(text);
			return this;
		}
		

		///<summary>The name of the tokenizer to use for the analysis</summary>
		public AnalyzeDescriptor Tokenizer(string tokenizer)
		{
			this._QueryString.Tokenizer(tokenizer);
			return this;
		}
		

		///<summary>Format of the output</summary>
		public AnalyzeDescriptor Format(FormatOptions format)
		{
			this._QueryString.Format(format);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesClearCacheForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html
	///</pre>
	///</summary>
	public partial class ClearCacheDescriptor
	{
		internal ClearCacheQueryString _QueryString = new ClearCacheQueryString(); 


		///<summary>Clear field data</summary>
		public ClearCacheDescriptor FieldData(bool field_data = true)
		{
			this._QueryString.FieldData(field_data);
			return this;
		}
		

		///<summary>Clear field data</summary>
		public ClearCacheDescriptor Fielddata(bool fielddata = true)
		{
			this._QueryString.Fielddata(fielddata);
			return this;
		}
		

		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Clear filter caches</summary>
		public ClearCacheDescriptor Filter(bool filter = true)
		{
			this._QueryString.Filter(filter);
			return this;
		}
		

		///<summary>Clear filter caches</summary>
		public ClearCacheDescriptor FilterCache(bool filter_cache = true)
		{
			this._QueryString.FilterCache(filter_cache);
			return this;
		}
		

		///<summary>A comma-separated list of keys to clear when using the `filter_cache` parameter (default: all)</summary>
		public ClearCacheDescriptor FilterKeys(bool filter_keys = true)
		{
			this._QueryString.FilterKeys(filter_keys);
			return this;
		}
		

		///<summary>Clear ID caches for parent/child</summary>
		public ClearCacheDescriptor Id(bool id = true)
		{
			this._QueryString.Id(id);
			return this;
		}
		

		///<summary>Clear ID caches for parent/child</summary>
		public ClearCacheDescriptor IdCache(bool id_cache = true)
		{
			this._QueryString.IdCache(id_cache);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClearCacheDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClearCacheDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClearCacheDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor IndexQueryString(params string[] index)
		{
			this._QueryString.Index(index);
			return this;
		}
		

		///<summary>Clear the recycler cache</summary>
		public ClearCacheDescriptor Recycler(bool recycler = true)
		{
			this._QueryString.Recycler(recycler);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesClose
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html
	///</pre>
	///</summary>
	public partial class CloseIndexDescriptor
	{
		internal CloseIndexQueryString _QueryString = new CloseIndexQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public CloseIndexDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public CloseIndexDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CloseIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CloseIndexDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CloseIndexDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesCreate
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html
	///</pre>
	///</summary>
	public partial class CreateIndexDescriptor
	{
		internal CreateIndexQueryString _QueryString = new CreateIndexQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public CreateIndexDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public CreateIndexDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesDelete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html
	///</pre>
	///</summary>
	public partial class DeleteIndexDescriptor
	{
		internal DeleteIndexQueryString _QueryString = new DeleteIndexQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public DeleteIndexDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesDeleteAlias
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesDeleteAliasDescriptor
	{
		internal IndicesDeleteAliasQueryString _QueryString = new IndicesDeleteAliasQueryString(); 


		///<summary>Explicit timestamp for the document</summary>
		public IndicesDeleteAliasDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public IndicesDeleteAliasDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesDeleteMapping
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html
	///</pre>
	///</summary>
	public partial class DeleteMappingDescriptor
	{
		internal DeleteMappingQueryString _QueryString = new DeleteMappingQueryString(); 


		///<summary>Specify timeout for connection to master</summary>
		public DeleteMappingDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesDeleteTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class DeleteTemplateDescriptor
	{
		internal DeleteTemplateQueryString _QueryString = new DeleteTemplateQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public DeleteTemplateDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public DeleteTemplateDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesDeleteWarmer
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class DeleteWarmerDescriptor
	{
		internal DeleteWarmerQueryString _QueryString = new DeleteWarmerQueryString(); 


		///<summary>Specify timeout for connection to master</summary>
		public DeleteWarmerDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesExists
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html
	///</pre>
	///</summary>
	public partial class IndexExistsDescriptor
	{
		internal IndexExistsQueryString _QueryString = new IndexExistsQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndexExistsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndexExistsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndexExistsDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexExistsDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesExistsAliasForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesExistsAliasDescriptor
	{
		internal IndicesExistsAliasQueryString _QueryString = new IndicesExistsAliasQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesExistsAliasDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesExistsAliasDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesExistsAliasDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsAliasDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesExistsTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class IndicesExistsTemplateDescriptor
	{
		internal IndicesExistsTemplateQueryString _QueryString = new IndicesExistsTemplateQueryString(); 


		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsTemplateDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesExistsType
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html
	///</pre>
	///</summary>
	public partial class IndicesExistsTypeDescriptor
	{
		internal IndicesExistsTypeQueryString _QueryString = new IndicesExistsTypeQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesExistsTypeDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesExistsTypeDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesExistsTypeDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesExistsTypeDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesFlushForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html
	///</pre>
	///</summary>
	public partial class FlushDescriptor
	{
		internal FlushQueryString _QueryString = new FlushQueryString(); 


		///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public FlushDescriptor Force(bool force = true)
		{
			this._QueryString.Force(force);
			return this;
		}
		

		///<summary>If set to true a new index writer is created and settings that have been changed related to the index writer will be refreshed. Note: if a full flush is required for a setting to take effect this will be part of the settings update process and it not required to be executed by the user. (This setting can be considered as internal)</summary>
		public FlushDescriptor Full(bool full = true)
		{
			this._QueryString.Full(full);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FlushDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FlushDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FlushDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetAliasForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class GetAliasesDescriptor
	{
		internal GetAliasesQueryString _QueryString = new GetAliasesQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetAliasesDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetAliasesDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetAliasesDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasesDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetAliasesForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesGetAliasesDescriptor
	{
		internal IndicesGetAliasesQueryString _QueryString = new IndicesGetAliasesQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public IndicesGetAliasesDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesGetAliasesDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetFieldMappingForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html
	///</pre>
	///</summary>
	public partial class IndicesGetFieldMappingDescriptor
	{
		internal IndicesGetFieldMappingQueryString _QueryString = new IndicesGetFieldMappingQueryString(); 


		///<summary>Whether the default mapping values should be returned as well</summary>
		public IndicesGetFieldMappingDescriptor IncludeDefaults(bool include_defaults = true)
		{
			this._QueryString.IncludeDefaults(include_defaults);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesGetFieldMappingDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesGetFieldMappingDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesGetFieldMappingDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndicesGetFieldMappingDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetMappingForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html
	///</pre>
	///</summary>
	public partial class GetMappingDescriptor
	{
		internal GetMappingQueryString _QueryString = new GetMappingQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetMappingDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetMappingDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetMappingDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetMappingDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetSettingsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html
	///</pre>
	///</summary>
	public partial class GetIndexSettingsDescriptor
	{
		internal GetIndexSettingsQueryString _QueryString = new GetIndexSettingsQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetIndexSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetIndexSettingsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexSettingsDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class GetTemplateDescriptor
	{
		internal GetTemplateQueryString _QueryString = new GetTemplateQueryString(); 


		///<summary>Return settings in flat format (default: false)</summary>
		public GetTemplateDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetTemplateDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesGetWarmerForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class GetWarmerDescriptor
	{
		internal GetWarmerQueryString _QueryString = new GetWarmerQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetWarmerDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetWarmerDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetWarmerDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesOpen
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html
	///</pre>
	///</summary>
	public partial class OpenIndexDescriptor
	{
		internal OpenIndexQueryString _QueryString = new OpenIndexQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public OpenIndexDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public OpenIndexDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OpenIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OpenIndexDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OpenIndexDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesOptimizeForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html
	///</pre>
	///</summary>
	public partial class OptimizeDescriptor
	{
		internal OptimizeQueryString _QueryString = new OptimizeQueryString(); 


		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public OptimizeDescriptor Flush(bool flush = true)
		{
			this._QueryString.Flush(flush);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OptimizeDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OptimizeDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OptimizeDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public OptimizeDescriptor MaxNumSegments(int max_num_segments)
		{
			this._QueryString.MaxNumSegments(max_num_segments);
			return this;
		}
		

		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public OptimizeDescriptor OnlyExpungeDeletes(bool only_expunge_deletes = true)
		{
			this._QueryString.OnlyExpungeDeletes(only_expunge_deletes);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public OptimizeDescriptor OperationThreading(string operation_threading)
		{
			this._QueryString.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>Specify whether the request should block until the merge process is finished (default: true)</summary>
		public OptimizeDescriptor WaitForMerge(bool wait_for_merge = true)
		{
			this._QueryString.WaitForMerge(wait_for_merge);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesPutAlias
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class IndicesPutAliasDescriptor
	{
		internal IndicesPutAliasQueryString _QueryString = new IndicesPutAliasQueryString(); 


		///<summary>Explicit timestamp for the document</summary>
		public IndicesPutAliasDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public IndicesPutAliasDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesPutMapping
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html
	///</pre>
	///</summary>
	public partial class PutMappingDescriptor<T>
	{
		internal PutMappingQueryString _QueryString = new PutMappingQueryString(); 


		///<summary>Specify whether to ignore conflicts while updating the mapping (default: false)</summary>
		public PutMappingDescriptor<T> IgnoreConflicts(bool ignore_conflicts = true)
		{
			this._QueryString.IgnoreConflicts(ignore_conflicts);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public PutMappingDescriptor<T> Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public PutMappingDescriptor<T> MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PutMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PutMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PutMappingDescriptor<T> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesPutSettingsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html
	///</pre>
	///</summary>
	public partial class UpdateSettingsDescriptor
	{
		internal UpdateSettingsQueryString _QueryString = new UpdateSettingsQueryString(); 


		///<summary>Specify timeout for connection to master</summary>
		public UpdateSettingsDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateSettingsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateSettingsDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public UpdateSettingsDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesPutTemplateForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html
	///</pre>
	///</summary>
	public partial class PutTemplateDescriptor
	{
		internal PutTemplateQueryString _QueryString = new PutTemplateQueryString(); 


		///<summary>Explicit operation timeout</summary>
		public PutTemplateDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public PutTemplateDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Return settings in flat format (default: false)</summary>
		public PutTemplateDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesPutWarmerForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html
	///</pre>
	///</summary>
	public partial class PutWarmerDescriptor
	{
		internal PutWarmerQueryString _QueryString = new PutWarmerQueryString(); 


		///<summary>Specify timeout for connection to master</summary>
		public PutWarmerDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm</summary>
		public PutWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)</summary>
		public PutWarmerDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.</summary>
		public PutWarmerDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesRefreshForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html
	///</pre>
	///</summary>
	public partial class RefreshDescriptor
	{
		internal RefreshQueryString _QueryString = new RefreshQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public RefreshDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public RefreshDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public RefreshDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Force a refresh even if not required</summary>
		public RefreshDescriptor Force(bool force = true)
		{
			this._QueryString.Force(force);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public RefreshDescriptor OperationThreading(string operation_threading)
		{
			this._QueryString.OperationThreading(operation_threading);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesSegmentsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html
	///</pre>
	///</summary>
	public partial class SegmentsDescriptor
	{
		internal SegmentsQueryString _QueryString = new SegmentsQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SegmentsDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SegmentsDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SegmentsDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public SegmentsDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public SegmentsDescriptor OperationThreading(string operation_threading)
		{
			this._QueryString.OperationThreading(operation_threading);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesSnapshotIndexForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html
	///</pre>
	///</summary>
	public partial class SnapshotDescriptor
	{
		internal SnapshotQueryString _QueryString = new SnapshotQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SnapshotDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SnapshotDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SnapshotDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesStatsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html
	///</pre>
	///</summary>
	public partial class IndicesStatsDescriptor
	{
		internal IndicesStatsQueryString _QueryString = new IndicesStatsQueryString(); 


		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields(params string[] completion_fields)
		{
			this._QueryString.CompletionFields(completion_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._CompletionFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields(params string[] fielddata_fields)
		{
			this._QueryString.FielddataFields(fielddata_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._FielddataFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public IndicesStatsDescriptor Groups(bool groups = true)
		{
			this._QueryString.Groups(groups);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesStatsDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		

		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public IndicesStatsDescriptor Level(LevelOptions level)
		{
			this._QueryString.Level(level);
			return this;
		}
		

		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public IndicesStatsDescriptor Types(params string[] types)
		{
			this._QueryString.Types(types);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesStatusForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html
	///</pre>
	///</summary>
	public partial class IndicesStatusDescriptor
	{
		internal IndicesStatusQueryString _QueryString = new IndicesStatusQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesStatusDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesStatusDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesStatusDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesStatusDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public IndicesStatusDescriptor OperationThreading(string operation_threading)
		{
			this._QueryString.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>Return information about shard recovery</summary>
		public IndicesStatusDescriptor Recovery(bool recovery = true)
		{
			this._QueryString.Recovery(recovery);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public IndicesStatusDescriptor Snapshot(bool snapshot = true)
		{
			this._QueryString.Snapshot(snapshot);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesUpdateAliasesForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html
	///</pre>
	///</summary>
	public partial class AliasDescriptor
	{
		internal AliasQueryString _QueryString = new AliasQueryString(); 


		///<summary>Request timeout</summary>
		public AliasDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Specify timeout for connection to master</summary>
		public AliasDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for IndicesValidateQueryGetForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html
	///</pre>
	///</summary>
	public partial class ValidateQueryDescriptor<T>
	{
		internal ValidateQueryQueryString _QueryString = new ValidateQueryQueryString(); 


		///<summary>Return detailed information about the error</summary>
		public ValidateQueryDescriptor<T> Explain(bool explain = true)
		{
			this._QueryString.Explain(explain);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ValidateQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ValidateQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ValidateQueryDescriptor<T> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>TODO: ?</summary>
		public ValidateQueryDescriptor<T> OperationThreading(string operation_threading)
		{
			this._QueryString.OperationThreading(operation_threading);
			return this;
		}
		

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public ValidateQueryDescriptor<T> Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		

		///<summary>Query in the Lucene query string syntax</summary>
		public ValidateQueryDescriptor<T> Q(string q)
		{
			this._QueryString.Q(q);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Info
	///<pre>
	///http://www.elasticsearch.org/guide/
	///</pre>
	///</summary>
	public partial class InfoDescriptor
	{
		internal InfoQueryString _QueryString = new InfoQueryString(); 

		
	}
	
	
	///<summary>descriptor for MgetGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html
	///</pre>
	///</summary>
	public partial class MultiGetDescriptor
	{
		internal MultiGetQueryString _QueryString = new MultiGetQueryString(); 


		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public MultiGetDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public MultiGetDescriptor Realtime(bool realtime = true)
		{
			this._QueryString.Realtime(realtime);
			return this;
		}
		

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public MultiGetDescriptor Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public MultiGetDescriptor Source(params string[] _source)
		{
			this._QueryString.Source(_source);
			return this;
		}
		

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude(params string[] _source_exclude)
		{
			this._QueryString.SourceExclude(_source_exclude);
			return this;
		}
		
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceExclude(typedPathLookups);
			return this;
		}
			

		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude(params string[] _source_include)
		{
			this._QueryString.SourceInclude(_source_include);
			return this;
		}
		
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._SourceInclude(typedPathLookups);
			return this;
		}
			
		
	}
	
	
	///<summary>descriptor for MltGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html
	///</pre>
	///</summary>
	public partial class MoreLikeThisDescriptor<T>
	{
		internal MoreLikeThisQueryString _QueryString = new MoreLikeThisQueryString(); 


		///<summary>The boost factor</summary>
		public MoreLikeThisDescriptor<T> BoostTerms(double boost_terms)
		{
			this._QueryString.BoostTerms(boost_terms);
			return this;
		}
		

		///<summary>The word occurrence frequency as count: words with higher occurrence in the corpus will be ignored</summary>
		public MoreLikeThisDescriptor<T> MaxDocFreq(int max_doc_freq)
		{
			this._QueryString.MaxDocFreq(max_doc_freq);
			return this;
		}
		

		///<summary>The maximum query terms to be included in the generated query</summary>
		public MoreLikeThisDescriptor<T> MaxQueryTerms(int max_query_terms)
		{
			this._QueryString.MaxQueryTerms(max_query_terms);
			return this;
		}
		

		///<summary>The minimum length of the word: longer words will be ignored</summary>
		public MoreLikeThisDescriptor<T> MaxWordLength(int max_word_length)
		{
			this._QueryString.MaxWordLength(max_word_length);
			return this;
		}
		

		///<summary>The word occurrence frequency as count: words with lower occurrence in the corpus will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinDocFreq(int min_doc_freq)
		{
			this._QueryString.MinDocFreq(min_doc_freq);
			return this;
		}
		

		///<summary>The term frequency as percent: terms with lower occurence in the source document will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinTermFreq(int min_term_freq)
		{
			this._QueryString.MinTermFreq(min_term_freq);
			return this;
		}
		

		///<summary>The minimum length of the word: shorter words will be ignored</summary>
		public MoreLikeThisDescriptor<T> MinWordLength(int min_word_length)
		{
			this._QueryString.MinWordLength(min_word_length);
			return this;
		}
		

		///<summary>Specific fields to perform the query against</summary>
		public MoreLikeThisDescriptor<T> MltFields(params string[] mlt_fields)
		{
			this._QueryString.MltFields(mlt_fields);
			return this;
		}
		
			
		///<summary>Specific fields to perform the query against</summary>
		public MoreLikeThisDescriptor<T> MltFields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._MltFields(typedPathLookups);
			return this;
		}
			

		///<summary>How many terms have to match in order to consider the document a match (default: 0.3)</summary>
		public MoreLikeThisDescriptor<T> PercentTermsToMatch(double percent_terms_to_match)
		{
			this._QueryString.PercentTermsToMatch(percent_terms_to_match);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public MoreLikeThisDescriptor<T> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The offset from which to return results</summary>
		public MoreLikeThisDescriptor<T> SearchFrom(int search_from)
		{
			this._QueryString.SearchFrom(search_from);
			return this;
		}
		

		///<summary>A comma-separated list of indices to perform the query against (default: the index containing the document)</summary>
		public MoreLikeThisDescriptor<T> SearchIndices(params string[] search_indices)
		{
			this._QueryString.SearchIndices(search_indices);
			return this;
		}
		

		///<summary>The search query hint</summary>
		public MoreLikeThisDescriptor<T> SearchQueryHint(string search_query_hint)
		{
			this._QueryString.SearchQueryHint(search_query_hint);
			return this;
		}
		

		///<summary>A scroll search request definition</summary>
		public MoreLikeThisDescriptor<T> SearchScroll(string search_scroll)
		{
			this._QueryString.SearchScroll(search_scroll);
			return this;
		}
		

		///<summary>The number of documents to return (default: 10)</summary>
		public MoreLikeThisDescriptor<T> SearchSize(int search_size)
		{
			this._QueryString.SearchSize(search_size);
			return this;
		}
		

		///<summary>A specific search request definition (instead of using the request body)</summary>
		public MoreLikeThisDescriptor<T> SearchSource(string search_source)
		{
			this._QueryString.SearchSource(search_source);
			return this;
		}
		

		///<summary>Specific search type (eg. `dfs_then_fetch`, `count`, etc)</summary>
		public MoreLikeThisDescriptor<T> SearchType(string search_type)
		{
			this._QueryString.SearchType(search_type);
			return this;
		}
		

		///<summary>A comma-separated list of types to perform the query against (default: the same type as the document)</summary>
		public MoreLikeThisDescriptor<T> SearchTypes(params string[] search_types)
		{
			this._QueryString.SearchTypes(search_types);
			return this;
		}
		

		///<summary>A list of stop words to be ignored</summary>
		public MoreLikeThisDescriptor<T> StopWords(params string[] stop_words)
		{
			this._QueryString.StopWords(stop_words);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for MpercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class MpercolateDescriptor
	{
		internal MpercolateQueryString _QueryString = new MpercolateQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public MpercolateDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public MpercolateDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public MpercolateDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for MsearchGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html
	///</pre>
	///</summary>
	public partial class MultiSearchDescriptor
	{
		internal MultiSearchQueryString _QueryString = new MultiSearchQueryString(); 


		///<summary>Search operation type</summary>
		public MultiSearchDescriptor SearchType(SearchTypeOptions search_type)
		{
			this._QueryString.SearchType(search_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for MtermvectorsGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html
	///</pre>
	///</summary>
	public partial class MtermvectorsDescriptor
	{
		internal MtermvectorsQueryString _QueryString = new MtermvectorsQueryString(); 


		///<summary>A comma-separated list of documents ids. You must define ids as parameter or set &quot;ids&quot; or &quot;docs&quot; in the request body</summary>
		public MtermvectorsDescriptor Ids(params string[] ids)
		{
			this._QueryString.Ids(ids);
			return this;
		}
		

		///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor TermStatistics(bool term_statistics = true)
		{
			this._QueryString.TermStatistics(term_statistics);
			return this;
		}
		

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor FieldStatistics(bool field_statistics = true)
		{
			this._QueryString.FieldStatistics(field_statistics);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Offsets(bool offsets = true)
		{
			this._QueryString.Offsets(offsets);
			return this;
		}
		

		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Positions(bool positions = true)
		{
			this._QueryString.Positions(positions);
			return this;
		}
		

		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Payloads(bool payloads = true)
		{
			this._QueryString.Payloads(payloads);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Parent id of documents. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MtermvectorsDescriptor Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for NodesHotThreadsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html
	///</pre>
	///</summary>
	public partial class NodesHotThreadsDescriptor
	{
		internal NodesHotThreadsQueryString _QueryString = new NodesHotThreadsQueryString(); 


		///<summary>The interval for the second sampling of threads</summary>
		public NodesHotThreadsDescriptor Interval(string interval)
		{
			this._QueryString.Interval(interval);
			return this;
		}
		

		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public NodesHotThreadsDescriptor Snapshots(int snapshots)
		{
			this._QueryString.Snapshots(snapshots);
			return this;
		}
		

		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public NodesHotThreadsDescriptor Threads(int threads)
		{
			this._QueryString.Threads(threads);
			return this;
		}
		

		///<summary>The type to sample (default: cpu)</summary>
		public NodesHotThreadsDescriptor TypeQueryString(TypeOptions type)
		{
			this._QueryString.Type(type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for NodesInfoForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html
	///</pre>
	///</summary>
	public partial class NodesInfoDescriptor
	{
		internal NodesInfoQueryString _QueryString = new NodesInfoQueryString(); 


		///<summary>Return settings in flat format (default: false)</summary>
		public NodesInfoDescriptor FlatSettings(bool flat_settings = true)
		{
			this._QueryString.FlatSettings(flat_settings);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesInfoDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for NodesShutdownForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html
	///</pre>
	///</summary>
	public partial class NodesShutdownDescriptor
	{
		internal NodesShutdownQueryString _QueryString = new NodesShutdownQueryString(); 


		///<summary>Set the delay for the operation (default: 1s)</summary>
		public NodesShutdownDescriptor Delay(string delay)
		{
			this._QueryString.Delay(delay);
			return this;
		}
		

		///<summary>Exit the JVM as well (default: true)</summary>
		public NodesShutdownDescriptor Exit(bool exit = true)
		{
			this._QueryString.Exit(exit);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for NodesStatsForAll
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html
	///</pre>
	///</summary>
	public partial class NodesStatsDescriptor
	{
		internal NodesStatsQueryString _QueryString = new NodesStatsQueryString(); 


		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields(params string[] completion_fields)
		{
			this._QueryString.CompletionFields(completion_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._CompletionFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields(params string[] fielddata_fields)
		{
			this._QueryString.FielddataFields(fielddata_fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._FielddataFields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public NodesStatsDescriptor Groups(bool groups = true)
		{
			this._QueryString.Groups(groups);
			return this;
		}
		

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesStatsDescriptor Human(bool human = true)
		{
			this._QueryString.Human(human);
			return this;
		}
		

		///<summary>Return indices stats aggregated at node, index or shard level</summary>
		public NodesStatsDescriptor Level(LevelOptions level)
		{
			this._QueryString.Level(level);
			return this;
		}
		

		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public NodesStatsDescriptor Types(params string[] types)
		{
			this._QueryString.Types(types);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for PercolateGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html
	///</pre>
	///</summary>
	public partial class PercolateDescriptor<T,K>
	{
		internal PercolateQueryString _QueryString = new PercolateQueryString(); 


		///<summary>A comma-separated list of specific routing values</summary>
		public PercolateDescriptor<T,K> Routing(params string[] routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public PercolateDescriptor<T,K> Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PercolateDescriptor<T,K> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PercolateDescriptor<T,K> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PercolateDescriptor<T,K> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>The index to percolate the document into. Defaults to index.</summary>
		public PercolateDescriptor<T,K> PercolateIndex(string percolate_index)
		{
			this._QueryString.PercolateIndex(percolate_index);
			return this;
		}
		

		///<summary>The type to percolate document into. Defaults to type.</summary>
		public PercolateDescriptor<T,K> PercolateType(string percolate_type)
		{
			this._QueryString.PercolateType(percolate_type);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public PercolateDescriptor<T,K> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public PercolateDescriptor<T,K> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Ping
	///<pre>
	///http://www.elasticsearch.org/guide/
	///</pre>
	///</summary>
	public partial class PingDescriptor
	{
		internal PingQueryString _QueryString = new PingQueryString(); 

		
	}
	
	
	///<summary>descriptor for ScrollGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html
	///</pre>
	///</summary>
	public partial class ScrollDescriptor<T>
	{
		internal ScrollQueryString _QueryString = new ScrollQueryString(); 


		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public ScrollDescriptor<T> Scroll(string scroll)
		{
			this._QueryString.Scroll(scroll);
			return this;
		}
		

		///<summary>The scroll ID for scrolled search</summary>
		public ScrollDescriptor<T> ScrollId(string scroll_id)
		{
			this._QueryString.ScrollId(scroll_id);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SearchGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html
	///</pre>
	///</summary>
	public partial class SearchDescriptor<T>
	{
		internal SearchQueryString _QueryString = new SearchQueryString(); 


		///<summary>The analyzer to use for the query string</summary>
		public SearchDescriptor<T> Analyzer(string analyzer)
		{
			this._QueryString.Analyzer(analyzer);
			return this;
		}
		

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true)
		{
			this._QueryString.AnalyzeWildcard(analyze_wildcard);
			return this;
		}
		

		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchDescriptor<T> DefaultOperator(DefaultOperatorOptions default_operator)
		{
			this._QueryString.DefaultOperator(default_operator);
			return this;
		}
		

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchDescriptor<T> Df(string df)
		{
			this._QueryString.Df(df);
			return this;
		}
		

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchDescriptor<T> AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchDescriptor<T> ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Comma-separated list of index boosts</summary>
		public SearchDescriptor<T> IndicesBoost(params string[] indices_boost)
		{
			this._QueryString.IndicesBoost(indices_boost);
			return this;
		}
		

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchDescriptor<T> Lenient(bool lenient = true)
		{
			this._QueryString.Lenient(lenient);
			return this;
		}
		

		///<summary>Specify whether query terms should be lowercased</summary>
		public SearchDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true)
		{
			this._QueryString.LowercaseExpandedTerms(lowercase_expanded_terms);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchDescriptor<T> Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>A comma-separated list of specific routing values</summary>
		public SearchDescriptor<T> Routing(params string[] routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchDescriptor<T> Scroll(string scroll)
		{
			this._QueryString.Scroll(scroll);
			return this;
		}
		

		///<summary>Search operation type</summary>
		public SearchDescriptor<T> SearchType(SearchTypeOptions search_type)
		{
			this._QueryString.SearchType(search_type);
			return this;
		}
		

		///<summary>The URL-encoded request definition using the Query DSL (instead of using request body)</summary>
		public SearchDescriptor<T> Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		

		///<summary>Specific &#39;tag&#39; of the request for logging and statistical purposes</summary>
		public SearchDescriptor<T> Stats(params string[] stats)
		{
			this._QueryString.Stats(stats);
			return this;
		}
		

		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(string suggest_field)
		{
			this._QueryString.SuggestField(suggest_field);
			return this;
		}
		
			
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Expression<Func<T, object>> typedPathLookup) 
		{
			typedPathLookup.ThrowIfNull("typedPathLookup");
			this._QueryString._SuggestField(typedPathLookup);
			return this;
		}
			

		///<summary>Specify suggest mode</summary>
		public SearchDescriptor<T> SuggestMode(SuggestModeOptions suggest_mode)
		{
			this._QueryString.SuggestMode(suggest_mode);
			return this;
		}
		

		///<summary>How many suggestions to return in response</summary>
		public SearchDescriptor<T> SuggestSize(int suggest_size)
		{
			this._QueryString.SuggestSize(suggest_size);
			return this;
		}
		

		///<summary>The source text for which the suggestions should be returned</summary>
		public SearchDescriptor<T> SuggestText(string suggest_text)
		{
			this._QueryString.SuggestText(suggest_text);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotCreate
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotCreateDescriptor
	{
		internal SnapshotCreateQueryString _QueryString = new SnapshotCreateQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotCreateDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotCreateDescriptor WaitForCompletion(bool wait_for_completion = true)
		{
			this._QueryString.WaitForCompletion(wait_for_completion);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotCreateRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotCreateRepositoryDescriptor
	{
		internal SnapshotCreateRepositoryQueryString _QueryString = new SnapshotCreateRepositoryQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotCreateRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public SnapshotCreateRepositoryDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotDelete
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotDeleteDescriptor
	{
		internal SnapshotDeleteQueryString _QueryString = new SnapshotDeleteQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDeleteDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotDeleteRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotDeleteRepositoryDescriptor
	{
		internal SnapshotDeleteRepositoryQueryString _QueryString = new SnapshotDeleteRepositoryQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDeleteRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public SnapshotDeleteRepositoryDescriptor Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotGetDescriptor
	{
		internal SnapshotGetQueryString _QueryString = new SnapshotGetQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotGetDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotGetRepository
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotGetRepositoryDescriptor
	{
		internal SnapshotGetRepositoryQueryString _QueryString = new SnapshotGetRepositoryQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotGetRepositoryDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SnapshotGetRepositoryDescriptor Local(bool local = true)
		{
			this._QueryString.Local(local);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for SnapshotRestore
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html
	///</pre>
	///</summary>
	public partial class SnapshotRestoreDescriptor
	{
		internal SnapshotRestoreQueryString _QueryString = new SnapshotRestoreQueryString(); 


		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotRestoreDescriptor MasterTimeout(string master_timeout)
		{
			this._QueryString.MasterTimeout(master_timeout);
			return this;
		}
		

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotRestoreDescriptor WaitForCompletion(bool wait_for_completion = true)
		{
			this._QueryString.WaitForCompletion(wait_for_completion);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Suggest
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html
	///</pre>
	///</summary>
	public partial class SuggestDescriptor
	{
		internal SuggestQueryString _QueryString = new SuggestQueryString(); 


		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SuggestDescriptor IgnoreUnavailable(bool ignore_unavailable = true)
		{
			this._QueryString.IgnoreUnavailable(ignore_unavailable);
			return this;
		}
		

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SuggestDescriptor AllowNoIndices(bool allow_no_indices = true)
		{
			this._QueryString.AllowNoIndices(allow_no_indices);
			return this;
		}
		

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SuggestDescriptor ExpandWildcards(ExpandWildcardsOptions expand_wildcards)
		{
			this._QueryString.ExpandWildcards(expand_wildcards);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SuggestDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public SuggestDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded request definition (instead of using request body)</summary>
		public SuggestDescriptor Source(string source)
		{
			this._QueryString.Source(source);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for TermvectorGet
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html
	///</pre>
	///</summary>
	public partial class TermvectorDescriptor
	{
		internal TermvectorQueryString _QueryString = new TermvectorQueryString(); 


		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public TermvectorDescriptor TermStatistics(bool term_statistics = true)
		{
			this._QueryString.TermStatistics(term_statistics);
			return this;
		}
		

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public TermvectorDescriptor FieldStatistics(bool field_statistics = true)
		{
			this._QueryString.FieldStatistics(field_statistics);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return.</summary>
		public TermvectorDescriptor Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return.</summary>
		public TermvectorDescriptor Fields<T>(params Expression<Func<T, object>>[] typedPathLookups) where T : class
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>Specifies if term offsets should be returned.</summary>
		public TermvectorDescriptor Offsets(bool offsets = true)
		{
			this._QueryString.Offsets(offsets);
			return this;
		}
		

		///<summary>Specifies if term positions should be returned.</summary>
		public TermvectorDescriptor Positions(bool positions = true)
		{
			this._QueryString.Positions(positions);
			return this;
		}
		

		///<summary>Specifies if term payloads should be returned.</summary>
		public TermvectorDescriptor Payloads(bool payloads = true)
		{
			this._QueryString.Payloads(payloads);
			return this;
		}
		

		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public TermvectorDescriptor Preference(string preference)
		{
			this._QueryString.Preference(preference);
			return this;
		}
		

		///<summary>Specific routing value.</summary>
		public TermvectorDescriptor Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>Parent id of documents.</summary>
		public TermvectorDescriptor Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		
		
	}
	
	
	///<summary>descriptor for Update
	///<pre>
	///http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html
	///</pre>
	///</summary>
	public partial class UpdateDescriptor<T,K>
	{
		internal UpdateQueryString _QueryString = new UpdateQueryString(); 


		///<summary>Explicit write consistency setting for the operation</summary>
		public UpdateDescriptor<T,K> Consistency(ConsistencyOptions consistency)
		{
			this._QueryString.Consistency(consistency);
			return this;
		}
		

		///<summary>A comma-separated list of fields to return in the response</summary>
		public UpdateDescriptor<T,K> Fields(params string[] fields)
		{
			this._QueryString.Fields(fields);
			return this;
		}
		
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public UpdateDescriptor<T,K> Fields(params Expression<Func<T, object>>[] typedPathLookups) 
		{
			if (!typedPathLookups.HasAny())
				return this;

			this._QueryString._Fields(typedPathLookups);
			return this;
		}
			

		///<summary>The script language (default: mvel)</summary>
		public UpdateDescriptor<T,K> Lang(string lang)
		{
			this._QueryString.Lang(lang);
			return this;
		}
		

		///<summary>ID of the parent document</summary>
		public UpdateDescriptor<T,K> Parent(string parent)
		{
			this._QueryString.Parent(parent);
			return this;
		}
		

		///<summary>Refresh the index after performing the operation</summary>
		public UpdateDescriptor<T,K> Refresh(bool refresh = true)
		{
			this._QueryString.Refresh(refresh);
			return this;
		}
		

		///<summary>Specific replication type</summary>
		public UpdateDescriptor<T,K> Replication(ReplicationOptions replication)
		{
			this._QueryString.Replication(replication);
			return this;
		}
		

		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public UpdateDescriptor<T,K> RetryOnConflict(int retry_on_conflict)
		{
			this._QueryString.RetryOnConflict(retry_on_conflict);
			return this;
		}
		

		///<summary>Specific routing value</summary>
		public UpdateDescriptor<T,K> Routing(string routing)
		{
			this._QueryString.Routing(routing);
			return this;
		}
		

		///<summary>The URL-encoded script definition (instead of using request body)</summary>
		public UpdateDescriptor<T,K> ScriptQueryString(string script)
		{
			this._QueryString.Script(script);
			return this;
		}
		

		///<summary>Explicit operation timeout</summary>
		public UpdateDescriptor<T,K> Timeout(string timeout)
		{
			this._QueryString.Timeout(timeout);
			return this;
		}
		

		///<summary>Explicit timestamp for the document</summary>
		public UpdateDescriptor<T,K> Timestamp(string timestamp)
		{
			this._QueryString.Timestamp(timestamp);
			return this;
		}
		

		///<summary>Expiration time for the document</summary>
		public UpdateDescriptor<T,K> Ttl(string ttl)
		{
			this._QueryString.Ttl(ttl);
			return this;
		}
		

		///<summary>Explicit version number for concurrency control</summary>
		public UpdateDescriptor<T,K> Version(int version)
		{
			this._QueryString.Version(version);
			return this;
		}
		

		///<summary>Specific version type</summary>
		public UpdateDescriptor<T,K> VersionType(VersionTypeOptions version_type)
		{
			this._QueryString.VersionType(version_type);
			return this;
		}
		
		
	}
	
}
 