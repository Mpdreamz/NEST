// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗  
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝  
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// -----------------------------------------------
//  
// This file is automatically generated 
// Please do not edit these files manually
// Run the following in the root of the repos:
//
// 		*NIX 		:	./build.sh codegen
// 		Windows 	:	build.bat codegen
//
// -----------------------------------------------
// ReSharper disable RedundantUsingDirective
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using Elasticsearch.Net;
using Elasticsearch.Net.Utf8Json;
using Elasticsearch.Net.Specification.SecurityApi;

// ReSharper disable RedundantBaseConstructorCall
// ReSharper disable UnusedTypeParameter
// ReSharper disable PartialMethodWithSinglePart
// ReSharper disable RedundantNameQualifier
namespace Nest
{
	[InterfaceDataContract]
	public partial interface IAuthenticateRequest : IRequest<AuthenticateRequestParameters>
	{
	}

	///<summary>Request for Authenticate <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-authenticate.html</pre></summary>
	public partial class AuthenticateRequest : PlainRequestBase<AuthenticateRequestParameters>, IAuthenticateRequest
	{
		protected IAuthenticateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityAuthenticate;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IChangePasswordRequest : IRequest<ChangePasswordRequestParameters>
	{
		[IgnoreDataMember]
		string Username
		{
			get;
		}
	}

	///<summary>Request for ChangePassword <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-change-password.html</pre></summary>
	public partial class ChangePasswordRequest : PlainRequestBase<ChangePasswordRequestParameters>, IChangePasswordRequest
	{
		protected IChangePasswordRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityChangePassword;
		///<summary>/_security/user/{username}/_password</summary>
		///<param name = "username">Optional, accepts null</param>
		public ChangePasswordRequest(string username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user/_password</summary>
		public ChangePasswordRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IChangePasswordRequest.Username => Self.RouteValues.Get<string>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClearCachedRealmsRequest : IRequest<ClearCachedRealmsRequestParameters>
	{
		[IgnoreDataMember]
		Names Realms
		{
			get;
		}
	}

	///<summary>Request for ClearCachedRealms <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html</pre></summary>
	public partial class ClearCachedRealmsRequest : PlainRequestBase<ClearCachedRealmsRequestParameters>, IClearCachedRealmsRequest
	{
		protected IClearCachedRealmsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityClearCachedRealms;
		///<summary>/_security/realm/{realms}/_clear_cache</summary>
		///<param name = "realms">this parameter is required</param>
		public ClearCachedRealmsRequest(Names realms): base(r => r.Required("realms", realms))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected ClearCachedRealmsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IClearCachedRealmsRequest.Realms => Self.RouteValues.Get<Names>("realms");
		// Request parameters
		///<summary>Comma-separated list of usernames to clear from the cache</summary>
		public string[] Usernames
		{
			get => Q<string[]>("usernames");
			set => Q("usernames", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClearCachedRolesRequest : IRequest<ClearCachedRolesRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for ClearCachedRoles <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html</pre></summary>
	public partial class ClearCachedRolesRequest : PlainRequestBase<ClearCachedRolesRequestParameters>, IClearCachedRolesRequest
	{
		protected IClearCachedRolesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityClearCachedRoles;
		///<summary>/_security/role/{name}/_clear_cache</summary>
		///<param name = "name">this parameter is required</param>
		public ClearCachedRolesRequest(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected ClearCachedRolesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IClearCachedRolesRequest.Name => Self.RouteValues.Get<Names>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICreateApiKeyRequest : IRequest<CreateApiKeyRequestParameters>
	{
	}

	///<summary>Request for CreateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html</pre></summary>
	public partial class CreateApiKeyRequest : PlainRequestBase<CreateApiKeyRequestParameters>, ICreateApiKeyRequest
	{
		protected ICreateApiKeyRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityCreateApiKey;
		// values part of the url path
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeletePrivilegesRequest : IRequest<DeletePrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		string Application
		{
			get;
		}

		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for DeletePrivileges <pre>TODO</pre></summary>
	public partial class DeletePrivilegesRequest : PlainRequestBase<DeletePrivilegesRequestParameters>, IDeletePrivilegesRequest
	{
		protected IDeletePrivilegesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityDeletePrivileges;
		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public DeletePrivilegesRequest(string application, string name): base(r => r.Required("application", application).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected DeletePrivilegesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IDeletePrivilegesRequest.Application => Self.RouteValues.Get<string>("application");
		[IgnoreDataMember]
		string IDeletePrivilegesRequest.Name => Self.RouteValues.Get<string>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRoleRequest : IRequest<DeleteRoleRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for DeleteRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role.html</pre></summary>
	public partial class DeleteRoleRequest : PlainRequestBase<DeleteRoleRequestParameters>, IDeleteRoleRequest
	{
		protected IDeleteRoleRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityDeleteRole;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleRequest(string name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected DeleteRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IDeleteRoleRequest.Name => Self.RouteValues.Get<string>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRoleMappingRequest : IRequest<DeleteRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for DeleteRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role-mapping.html</pre></summary>
	public partial class DeleteRoleMappingRequest : PlainRequestBase<DeleteRoleMappingRequestParameters>, IDeleteRoleMappingRequest
	{
		protected IDeleteRoleMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityDeleteRoleMapping;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleMappingRequest(string name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected DeleteRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IDeleteRoleMappingRequest.Name => Self.RouteValues.Get<string>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteUserRequest : IRequest<DeleteUserRequestParameters>
	{
		[IgnoreDataMember]
		string Username
		{
			get;
		}
	}

	///<summary>Request for DeleteUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-user.html</pre></summary>
	public partial class DeleteUserRequest : PlainRequestBase<DeleteUserRequestParameters>, IDeleteUserRequest
	{
		protected IDeleteUserRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityDeleteUser;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public DeleteUserRequest(string username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected DeleteUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IDeleteUserRequest.Username => Self.RouteValues.Get<string>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDisableUserRequest : IRequest<DisableUserRequestParameters>
	{
		[IgnoreDataMember]
		string Username
		{
			get;
		}
	}

	///<summary>Request for DisableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-disable-user.html</pre></summary>
	public partial class DisableUserRequest : PlainRequestBase<DisableUserRequestParameters>, IDisableUserRequest
	{
		protected IDisableUserRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityDisableUser;
		///<summary>/_security/user/{username}/_disable</summary>
		///<param name = "username">this parameter is required</param>
		public DisableUserRequest(string username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected DisableUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IDisableUserRequest.Username => Self.RouteValues.Get<string>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IEnableUserRequest : IRequest<EnableUserRequestParameters>
	{
		[IgnoreDataMember]
		string Username
		{
			get;
		}
	}

	///<summary>Request for EnableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-enable-user.html</pre></summary>
	public partial class EnableUserRequest : PlainRequestBase<EnableUserRequestParameters>, IEnableUserRequest
	{
		protected IEnableUserRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityEnableUser;
		///<summary>/_security/user/{username}/_enable</summary>
		///<param name = "username">this parameter is required</param>
		public EnableUserRequest(string username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected EnableUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IEnableUserRequest.Username => Self.RouteValues.Get<string>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetApiKeyRequest : IRequest<GetApiKeyRequestParameters>
	{
	}

	///<summary>Request for GetApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html</pre></summary>
	public partial class GetApiKeyRequest : PlainRequestBase<GetApiKeyRequestParameters>, IGetApiKeyRequest
	{
		protected IGetApiKeyRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetApiKey;
		// values part of the url path
		// Request parameters
		///<summary>API key id of the API key to be retrieved</summary>
		public string Id
		{
			get => Q<string>("id");
			set => Q("id", value);
		}

		///<summary>API key name of the API key to be retrieved</summary>
		public string Name
		{
			get => Q<string>("name");
			set => Q("name", value);
		}

		///<summary>realm name of the user who created this API key to be retrieved</summary>
		public string RealmName
		{
			get => Q<string>("realm_name");
			set => Q("realm_name", value);
		}

		///<summary>user name of the user who created this API key to be retrieved</summary>
		public string Username
		{
			get => Q<string>("username");
			set => Q("username", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetPrivilegesRequest : IRequest<GetPrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		string Application
		{
			get;
		}

		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for GetPrivileges <pre>TODO</pre></summary>
	public partial class GetPrivilegesRequest : PlainRequestBase<GetPrivilegesRequestParameters>, IGetPrivilegesRequest
	{
		protected IGetPrivilegesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetPrivileges;
		///<summary>/_security/privilege</summary>
		public GetPrivilegesRequest(): base()
		{
		}

		///<summary>/_security/privilege/{application}</summary>
		///<param name = "application">Optional, accepts null</param>
		public GetPrivilegesRequest(string application): base(r => r.Optional("application", application))
		{
		}

		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetPrivilegesRequest(string application, string name): base(r => r.Optional("application", application).Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IGetPrivilegesRequest.Application => Self.RouteValues.Get<string>("application");
		[IgnoreDataMember]
		string IGetPrivilegesRequest.Name => Self.RouteValues.Get<string>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRoleRequest : IRequest<GetRoleRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for GetRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html</pre></summary>
	public partial class GetRoleRequest : PlainRequestBase<GetRoleRequestParameters>, IGetRoleRequest
	{
		protected IGetRoleRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetRole;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleRequest(string name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role</summary>
		public GetRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IGetRoleRequest.Name => Self.RouteValues.Get<string>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRoleMappingRequest : IRequest<GetRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for GetRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html</pre></summary>
	public partial class GetRoleMappingRequest : PlainRequestBase<GetRoleMappingRequestParameters>, IGetRoleMappingRequest
	{
		protected IGetRoleMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetRoleMapping;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleMappingRequest(string name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role_mapping</summary>
		public GetRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IGetRoleMappingRequest.Name => Self.RouteValues.Get<string>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserAccessTokenRequest : IRequest<GetUserAccessTokenRequestParameters>
	{
	}

	///<summary>Request for GetUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html</pre></summary>
	public partial class GetUserAccessTokenRequest : PlainRequestBase<GetUserAccessTokenRequestParameters>, IGetUserAccessTokenRequest
	{
		protected IGetUserAccessTokenRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetUserAccessToken;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserRequest : IRequest<GetUserRequestParameters>
	{
		[IgnoreDataMember]
		Names Username
		{
			get;
		}
	}

	///<summary>Request for GetUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user.html</pre></summary>
	public partial class GetUserRequest : PlainRequestBase<GetUserRequestParameters>, IGetUserRequest
	{
		protected IGetUserRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetUser;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">Optional, accepts null</param>
		public GetUserRequest(Names username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user</summary>
		public GetUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IGetUserRequest.Username => Self.RouteValues.Get<Names>("username");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserPrivilegesRequest : IRequest<GetUserPrivilegesRequestParameters>
	{
	}

	///<summary>Request for GetUserPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-privileges.html</pre></summary>
	public partial class GetUserPrivilegesRequest : PlainRequestBase<GetUserPrivilegesRequestParameters>, IGetUserPrivilegesRequest
	{
		protected IGetUserPrivilegesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetUserPrivileges;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IHasPrivilegesRequest : IRequest<HasPrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		string User
		{
			get;
		}
	}

	///<summary>Request for HasPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html</pre></summary>
	public partial class HasPrivilegesRequest : PlainRequestBase<HasPrivilegesRequestParameters>, IHasPrivilegesRequest
	{
		protected IHasPrivilegesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityHasPrivileges;
		///<summary>/_security/user/_has_privileges</summary>
		public HasPrivilegesRequest(): base()
		{
		}

		///<summary>/_security/user/{user}/_has_privileges</summary>
		///<param name = "user">Optional, accepts null</param>
		public HasPrivilegesRequest(string user): base(r => r.Optional("user", user))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IHasPrivilegesRequest.User => Self.RouteValues.Get<string>("user");
	// Request parameters
	//TODO THIS METHOD IS UNMAPPED! Expected to find HasPrivilegesDescriptor and HasPrivilegesRequest in a file called HasPrivilegesRequest.cs in NEST's codebase
	}

	[InterfaceDataContract]
	public partial interface IInvalidateApiKeyRequest : IRequest<InvalidateApiKeyRequestParameters>
	{
	}

	///<summary>Request for InvalidateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html</pre></summary>
	public partial class InvalidateApiKeyRequest : PlainRequestBase<InvalidateApiKeyRequestParameters>, IInvalidateApiKeyRequest
	{
		protected IInvalidateApiKeyRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityInvalidateApiKey;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IInvalidateUserAccessTokenRequest : IRequest<InvalidateUserAccessTokenRequestParameters>
	{
	}

	///<summary>Request for InvalidateUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html</pre></summary>
	public partial class InvalidateUserAccessTokenRequest : PlainRequestBase<InvalidateUserAccessTokenRequestParameters>, IInvalidateUserAccessTokenRequest
	{
		protected IInvalidateUserAccessTokenRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityInvalidateUserAccessToken;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutPrivilegesRequest : IRequest<PutPrivilegesRequestParameters>
	{
	}

	///<summary>Request for PutPrivileges <pre>TODO</pre></summary>
	public partial class PutPrivilegesRequest : PlainRequestBase<PutPrivilegesRequestParameters>, IPutPrivilegesRequest
	{
		protected IPutPrivilegesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityPutPrivileges;
		// values part of the url path
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutRoleRequest : IRequest<PutRoleRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for PutRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html</pre></summary>
	public partial class PutRoleRequest : PlainRequestBase<PutRoleRequestParameters>, IPutRoleRequest
	{
		protected IPutRoleRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityPutRole;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleRequest(string name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected PutRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IPutRoleRequest.Name => Self.RouteValues.Get<string>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutRoleMappingRequest : IRequest<PutRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		string Name
		{
			get;
		}
	}

	///<summary>Request for PutRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html</pre></summary>
	public partial class PutRoleMappingRequest : PlainRequestBase<PutRoleMappingRequestParameters>, IPutRoleMappingRequest
	{
		protected IPutRoleMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityPutRoleMapping;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleMappingRequest(string name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected PutRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IPutRoleMappingRequest.Name => Self.RouteValues.Get<string>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutUserRequest : IRequest<PutUserRequestParameters>
	{
		[IgnoreDataMember]
		string Username
		{
			get;
		}
	}

	///<summary>Request for PutUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html</pre></summary>
	public partial class PutUserRequest : PlainRequestBase<PutUserRequestParameters>, IPutUserRequest
	{
		protected IPutUserRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityPutUser;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public PutUserRequest(string username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		protected PutUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		string IPutUserRequest.Username => Self.RouteValues.Get<string>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetCertificatesRequest : IRequest<GetCertificatesRequestParameters>
	{
	}

	///<summary>Request for GetCertificates <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-ssl.html</pre></summary>
	public partial class GetCertificatesRequest : PlainRequestBase<GetCertificatesRequestParameters>, IGetCertificatesRequest
	{
		protected IGetCertificatesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.SecurityGetCertificates;
	// values part of the url path
	// Request parameters
	}
}