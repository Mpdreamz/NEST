using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

///Generated File Please Do Not Edit Manually
	
namespace Elasticsearch.Net
{
	///<summary>
	///Raw operations with elasticsearch
	///</summary>
	public partial class ElasticsearchClient : IElasticsearchClient
	{
	
		
		///<summary>Represents a POST on /_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Bulk<T>(object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkAsync<T>(object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Bulk(object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkAsync(object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Bulk<T>(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkAsync<T>(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Bulk(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkAsync(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Bulk<T>(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkAsync<T>(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Bulk(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkAsync(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> BulkPut<T>(object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkPutAsync<T>(object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> BulkPut(object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkPutAsync(object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			var url = "_bulk".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> BulkPut<T>(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkPutAsync<T>(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> BulkPut(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkPutAsync(string index, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_bulk".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> BulkPut<T>(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_bulk
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> BulkPutAsync<T>(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_bulk
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> BulkPut(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_bulk
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-bulk.html</para>	
	    ///</summary>
		///<param name="index">Default index for items which don&#39;t provide one</param>
		///<param name="type">Default document type for items which don&#39;t provide one</param>
		///<param name="body">The operation definition and data (action-data pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> BulkPutAsync(string index, string type, object body, Func<BulkQueryString, BulkQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_bulk".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new BulkQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatAliases<T>(Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/aliases
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatAliasesAsync<T>(Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatAliases(Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null)
		{
			var url = "_cat/aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/aliases
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatAliasesAsync(Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null)
		{
			var url = "_cat/aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatAliases<T>(string name, Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_cat/aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/aliases/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatAliasesAsync<T>(string name, Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_cat/aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatAliases(string name, Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_cat/aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/aliases/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatAliasesAsync(string name, Func<CatAliasesQueryString, CatAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_cat/aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/allocation
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatAllocation<T>(Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/allocation";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/allocation
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatAllocationAsync<T>(Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/allocation";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/allocation
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatAllocation(Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null)
		{
			var url = "_cat/allocation";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/allocation
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatAllocationAsync(Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null)
		{
			var url = "_cat/allocation";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/allocation/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatAllocation<T>(string node_id, Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cat/allocation/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/allocation/{node_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatAllocationAsync<T>(string node_id, Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cat/allocation/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/allocation/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatAllocation(string node_id, Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cat/allocation/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/allocation/{node_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-allocation.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatAllocationAsync(string node_id, Func<CatAllocationQueryString, CatAllocationQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cat/allocation/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatAllocationQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatCount<T>(Func<CatCountQueryString, CatCountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatCountAsync<T>(Func<CatCountQueryString, CatCountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatCount(Func<CatCountQueryString, CatCountQueryString> queryString = null)
		{
			var url = "_cat/count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatCountAsync(Func<CatCountQueryString, CatCountQueryString> queryString = null)
		{
			var url = "_cat/count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/count/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatCount<T>(string index, Func<CatCountQueryString, CatCountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/count/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/count/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatCountAsync<T>(string index, Func<CatCountQueryString, CatCountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/count/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/count/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatCount(string index, Func<CatCountQueryString, CatCountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/count/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/count/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatCountAsync(string index, Func<CatCountQueryString, CatCountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/count/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatCountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/health
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatHealth<T>(Func<CatHealthQueryString, CatHealthQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/health
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatHealthAsync<T>(Func<CatHealthQueryString, CatHealthQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/health
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatHealth(Func<CatHealthQueryString, CatHealthQueryString> queryString = null)
		{
			var url = "_cat/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/health
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatHealthAsync(Func<CatHealthQueryString, CatHealthQueryString> queryString = null)
		{
			var url = "_cat/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatHelp<T>(Func<CatHelpQueryString, CatHelpQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHelpQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatHelpAsync<T>(Func<CatHelpQueryString, CatHelpQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHelpQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatHelp(Func<CatHelpQueryString, CatHelpQueryString> queryString = null)
		{
			var url = "_cat";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHelpQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatHelpAsync(Func<CatHelpQueryString, CatHelpQueryString> queryString = null)
		{
			var url = "_cat";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatHelpQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/indices
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatIndices<T>(Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/indices";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/indices
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatIndicesAsync<T>(Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/indices";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/indices
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatIndices(Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null)
		{
			var url = "_cat/indices";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/indices
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatIndicesAsync(Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null)
		{
			var url = "_cat/indices";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/indices/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatIndices<T>(string index, Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/indices/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/indices/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatIndicesAsync<T>(string index, Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/indices/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/indices/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatIndices(string index, Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/indices/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/indices/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-indices.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatIndicesAsync(string index, Func<CatIndicesQueryString, CatIndicesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/indices/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatIndicesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/master
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatMaster<T>(Func<CatMasterQueryString, CatMasterQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/master";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatMasterQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/master
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatMasterAsync<T>(Func<CatMasterQueryString, CatMasterQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/master";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatMasterQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/master
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatMaster(Func<CatMasterQueryString, CatMasterQueryString> queryString = null)
		{
			var url = "_cat/master";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatMasterQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/master
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-master.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatMasterAsync(Func<CatMasterQueryString, CatMasterQueryString> queryString = null)
		{
			var url = "_cat/master";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatMasterQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/nodes
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatNodes<T>(Func<CatNodesQueryString, CatNodesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatNodesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/nodes
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatNodesAsync<T>(Func<CatNodesQueryString, CatNodesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatNodesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/nodes
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatNodes(Func<CatNodesQueryString, CatNodesQueryString> queryString = null)
		{
			var url = "_cat/nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatNodesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/nodes
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-nodes.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatNodesAsync(Func<CatNodesQueryString, CatNodesQueryString> queryString = null)
		{
			var url = "_cat/nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatNodesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/pending_tasks
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatPendingTasks<T>(Func<CatPendingTasksQueryString, CatPendingTasksQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/pending_tasks
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatPendingTasksAsync<T>(Func<CatPendingTasksQueryString, CatPendingTasksQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/pending_tasks
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatPendingTasks(Func<CatPendingTasksQueryString, CatPendingTasksQueryString> queryString = null)
		{
			var url = "_cat/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/pending_tasks
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-pending-tasks.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatPendingTasksAsync(Func<CatPendingTasksQueryString, CatPendingTasksQueryString> queryString = null)
		{
			var url = "_cat/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/recovery
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatRecovery<T>(Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/recovery";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/recovery
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatRecoveryAsync<T>(Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/recovery";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/recovery
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatRecovery(Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null)
		{
			var url = "_cat/recovery";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/recovery
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatRecoveryAsync(Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null)
		{
			var url = "_cat/recovery";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/recovery/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatRecovery<T>(string index, Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/recovery/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/recovery/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatRecoveryAsync<T>(string index, Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/recovery/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/recovery/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatRecovery(string index, Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/recovery/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/recovery/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-recovery.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatRecoveryAsync(string index, Func<CatRecoveryQueryString, CatRecoveryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/recovery/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatRecoveryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/shards
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatShards<T>(Func<CatShardsQueryString, CatShardsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/shards";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/shards
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatShardsAsync<T>(Func<CatShardsQueryString, CatShardsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/shards";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/shards
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatShards(Func<CatShardsQueryString, CatShardsQueryString> queryString = null)
		{
			var url = "_cat/shards";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/shards
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatShardsAsync(Func<CatShardsQueryString, CatShardsQueryString> queryString = null)
		{
			var url = "_cat/shards";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/shards/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatShards<T>(string index, Func<CatShardsQueryString, CatShardsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/shards/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/shards/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatShardsAsync<T>(string index, Func<CatShardsQueryString, CatShardsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/shards/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/shards/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatShards(string index, Func<CatShardsQueryString, CatShardsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/shards/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/shards/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cat-shards.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to limit the returned information</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatShardsAsync(string index, Func<CatShardsQueryString, CatShardsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cat/shards/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatShardsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/thread_pool
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CatThreadPool<T>(Func<CatThreadPoolQueryString, CatThreadPoolQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/thread_pool";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatThreadPoolQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/thread_pool
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CatThreadPoolAsync<T>(Func<CatThreadPoolQueryString, CatThreadPoolQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cat/thread_pool";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatThreadPoolQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cat/thread_pool
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CatThreadPool(Func<CatThreadPoolQueryString, CatThreadPoolQueryString> queryString = null)
		{
			var url = "_cat/thread_pool";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatThreadPoolQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cat/thread_pool
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat-thread-pool.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CatThreadPoolAsync(Func<CatThreadPoolQueryString, CatThreadPoolQueryString> queryString = null)
		{
			var url = "_cat/thread_pool";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CatThreadPoolQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">A comma-separated list of scroll IDs to clear</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClearScroll<T>(string scroll_id, Func<ClearScrollQueryString, ClearScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_search/scroll/{scroll_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">A comma-separated list of scroll IDs to clear</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClearScrollAsync<T>(string scroll_id, Func<ClearScrollQueryString, ClearScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">A comma-separated list of scroll IDs to clear</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClearScroll(string scroll_id, Func<ClearScrollQueryString, ClearScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_search/scroll/{scroll_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">A comma-separated list of scroll IDs to clear</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClearScrollAsync(string scroll_id, Func<ClearScrollQueryString, ClearScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterGetSettings<T>(Func<ClusterGetSettingsQueryString, ClusterGetSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterGetSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterGetSettingsAsync<T>(Func<ClusterGetSettingsQueryString, ClusterGetSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterGetSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterGetSettings(Func<ClusterGetSettingsQueryString, ClusterGetSettingsQueryString> queryString = null)
		{
			var url = "_cluster/settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterGetSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterGetSettingsAsync(Func<ClusterGetSettingsQueryString, ClusterGetSettingsQueryString> queryString = null)
		{
			var url = "_cluster/settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterGetSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/health
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterHealth<T>(Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/health
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterHealthAsync<T>(Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/health
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterHealth(Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null)
		{
			var url = "_cluster/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/health
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterHealthAsync(Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null)
		{
			var url = "_cluster/health";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/health/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="index">Limit the information returned to a specific index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterHealth<T>(string index, Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/health/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/health/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="index">Limit the information returned to a specific index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterHealthAsync<T>(string index, Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/health/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/health/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="index">Limit the information returned to a specific index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterHealth(string index, Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/health/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/health/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-health.html</para>	
	    ///</summary>
		///<param name="index">Limit the information returned to a specific index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterHealthAsync(string index, Func<ClusterHealthQueryString, ClusterHealthQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/health/{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterHealthQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/pending_tasks
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterPendingTasks<T>(Func<ClusterPendingTasksQueryString, ClusterPendingTasksQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/pending_tasks
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterPendingTasksAsync<T>(Func<ClusterPendingTasksQueryString, ClusterPendingTasksQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/pending_tasks
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterPendingTasks(Func<ClusterPendingTasksQueryString, ClusterPendingTasksQueryString> queryString = null)
		{
			var url = "_cluster/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/pending_tasks
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-pending.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterPendingTasksAsync(Func<ClusterPendingTasksQueryString, ClusterPendingTasksQueryString> queryString = null)
		{
			var url = "_cluster/pending_tasks";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPendingTasksQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_cluster/settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The settings to be updated. Can be either `transient` or `persistent` (survives cluster restart).</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterPutSettings<T>(object body, Func<ClusterPutSettingsQueryString, ClusterPutSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPutSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_cluster/settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The settings to be updated. Can be either `transient` or `persistent` (survives cluster restart).</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterPutSettingsAsync<T>(object body, Func<ClusterPutSettingsQueryString, ClusterPutSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPutSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_cluster/settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The settings to be updated. Can be either `transient` or `persistent` (survives cluster restart).</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterPutSettings(object body, Func<ClusterPutSettingsQueryString, ClusterPutSettingsQueryString> queryString = null)
		{
			var url = "_cluster/settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPutSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_cluster/settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The settings to be updated. Can be either `transient` or `persistent` (survives cluster restart).</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterPutSettingsAsync(object body, Func<ClusterPutSettingsQueryString, ClusterPutSettingsQueryString> queryString = null)
		{
			var url = "_cluster/settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterPutSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cluster/reroute
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html</para>	
	    ///</summary>
		///<param name="body">The definition of `commands` to perform (`move`, `cancel`, `allocate`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterReroute<T>(object body, Func<ClusterRerouteQueryString, ClusterRerouteQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/reroute".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterRerouteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cluster/reroute
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html</para>	
	    ///</summary>
		///<param name="body">The definition of `commands` to perform (`move`, `cancel`, `allocate`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterRerouteAsync<T>(object body, Func<ClusterRerouteQueryString, ClusterRerouteQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/reroute".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterRerouteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cluster/reroute
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html</para>	
	    ///</summary>
		///<param name="body">The definition of `commands` to perform (`move`, `cancel`, `allocate`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterReroute(object body, Func<ClusterRerouteQueryString, ClusterRerouteQueryString> queryString = null)
		{
			var url = "_cluster/reroute".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterRerouteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cluster/reroute
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-reroute.html</para>	
	    ///</summary>
		///<param name="body">The definition of `commands` to perform (`move`, `cancel`, `allocate`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterRerouteAsync(object body, Func<ClusterRerouteQueryString, ClusterRerouteQueryString> queryString = null)
		{
			var url = "_cluster/reroute".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterRerouteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterState<T>(Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/state";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterStateAsync<T>(Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/state";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterState(Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			var url = "_cluster/state";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterStateAsync(Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			var url = "_cluster/state";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterState<T>(string metric, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_cluster/state/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterStateAsync<T>(string metric, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_cluster/state/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterState(string metric, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_cluster/state/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterStateAsync(string metric, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_cluster/state/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterState<T>(string metric, string index, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/state/{0}/{1}".F(Encoded(metric), Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}/{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterStateAsync<T>(string metric, string index, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/state/{0}/{1}".F(Encoded(metric), Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}/{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterState(string metric, string index, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/state/{0}/{1}".F(Encoded(metric), Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/state/{metric}/{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-state.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterStateAsync(string metric, string index, Func<ClusterStateQueryString, ClusterStateQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index.ThrowIfNullOrEmpty("index");
			var url = "_cluster/state/{0}/{1}".F(Encoded(metric), Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterStats<T>(Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/stats
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterStatsAsync<T>(Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterStats(Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null)
		{
			var url = "_cluster/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/stats
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterStatsAsync(Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null)
		{
			var url = "_cluster/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/stats/nodes/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ClusterStats<T>(string node_id, Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/stats/nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/stats/nodes/{node_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ClusterStatsAsync<T>(string node_id, Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/stats/nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/stats/nodes/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ClusterStats(string node_id, Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/stats/nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/stats/nodes/{node_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ClusterStatsAsync(string node_id, Func<ClusterStatsQueryString, ClusterStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/stats/nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClusterStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Count<T>(object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_count".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountAsync<T>(object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_count".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Count(object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			var url = "_count".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountAsync(object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			var url = "_count".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Count<T>(string index, object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountAsync<T>(string index, object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Count(string index, object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountAsync(string index, object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Count<T>(string index, string type, object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountAsync<T>(string index, string type, object body, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Count(string index, string type, object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="body">A query to restrict the results specified with the Query DSL (optional)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountAsync(string index, string type, object body, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountGet<T>(Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountGetAsync<T>(Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountGet(Func<CountQueryString, CountQueryString> queryString = null)
		{
			var url = "_count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountGetAsync(Func<CountQueryString, CountQueryString> queryString = null)
		{
			var url = "_count";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountGet<T>(string index, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountGetAsync<T>(string index, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountGet(string index, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountGetAsync(string index, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_count".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountGet<T>(string index, string type, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountGetAsync<T>(string index, string type, Func<CountQueryString, CountQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountGet(string index, string type, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-count.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the results</param>
		///<param name="type">A comma-separated list of types to restrict the results</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountGetAsync(string index, string type, Func<CountQueryString, CountQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountPercolateGet<T>(string index, string type, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate/count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountPercolateGetAsync<T>(string index, string type, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountPercolateGet(string index, string type, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate/count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountPercolateGetAsync(string index, string type, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountPercolateGet<T>(string index, string type, string id, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountPercolateGetAsync<T>(string index, string type, string id, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountPercolateGet(string index, string type, string id, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountPercolateGetAsync(string index, string type, string id, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountPercolate<T>(string index, string type, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate/count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountPercolateAsync<T>(string index, string type, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountPercolate(string index, string type, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate/count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountPercolateAsync(string index, string type, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate/count".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> CountPercolate<T>(string index, string type, string id, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> CountPercolateAsync<T>(string index, string type, string id, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> CountPercolate(string index, string type, string id, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate/count
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated.</param>
		///<param name="type">The type of the document being count percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The count percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> CountPercolateAsync(string index, string type, string id, object body, Func<CountPercolateQueryString, CountPercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate/count".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CountPercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Delete<T>(string index, string type, string id, Func<DeleteQueryString, DeleteQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/{id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> DeleteAsync<T>(string index, string type, string id, Func<DeleteQueryString, DeleteQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Delete(string index, string type, string id, Func<DeleteQueryString, DeleteQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/{id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> DeleteAsync(string index, string type, string id, Func<DeleteQueryString, DeleteQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> DeleteByQuery<T>(string index, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> DeleteByQueryAsync<T>(string index, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> DeleteByQuery(string index, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> DeleteByQueryAsync(string index, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of types to restrict the operation</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> DeleteByQuery<T>(string index, string type, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of types to restrict the operation</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> DeleteByQueryAsync<T>(string index, string type, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of types to restrict the operation</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> DeleteByQuery(string index, string type, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-delete-by-query.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of types to restrict the operation</param>
		///<param name="body">A query to restrict the operation specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> DeleteByQueryAsync(string index, string type, object body, Func<DeleteByQueryQueryString, DeleteByQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteByQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Exists<T>(string index, string type, string id, Func<ExistsQueryString, ExistsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/{type}/{id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ExistsAsync<T>(string index, string type, string id, Func<ExistsQueryString, ExistsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Exists(string index, string type, string id, Func<ExistsQueryString, ExistsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/{type}/{id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ExistsAsync(string index, string type, string id, Func<ExistsQueryString, ExistsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_explain
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ExplainGet<T>(string index, string type, string id, Func<ExplainQueryString, ExplainQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_explain
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ExplainGetAsync<T>(string index, string type, string id, Func<ExplainQueryString, ExplainQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_explain
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ExplainGet(string index, string type, string id, Func<ExplainQueryString, ExplainQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_explain
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ExplainGetAsync(string index, string type, string id, Func<ExplainQueryString, ExplainQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_explain
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="body">The query definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Explain<T>(string index, string type, string id, object body, Func<ExplainQueryString, ExplainQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_explain
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="body">The query definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ExplainAsync<T>(string index, string type, string id, object body, Func<ExplainQueryString, ExplainQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_explain
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="body">The query definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Explain(string index, string type, string id, object body, Func<ExplainQueryString, ExplainQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_explain
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-explain.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">The document ID</param>
		///<param name="body">The query definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ExplainAsync(string index, string type, string id, object body, Func<ExplainQueryString, ExplainQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_explain".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ExplainQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Get<T>(string index, string type, string id, Func<GetQueryString, GetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> GetAsync<T>(string index, string type, string id, Func<GetQueryString, GetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Get(string index, string type, string id, Func<GetQueryString, GetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> GetAsync(string index, string type, string id, Func<GetQueryString, GetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_source
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document; use `_all` to fetch the first document matching the ID across all types</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> GetSource<T>(string index, string type, string id, Func<SourceQueryString, SourceQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_source".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SourceQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_source
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document; use `_all` to fetch the first document matching the ID across all types</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> GetSourceAsync<T>(string index, string type, string id, Func<SourceQueryString, SourceQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_source".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SourceQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_source
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document; use `_all` to fetch the first document matching the ID across all types</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> GetSource(string index, string type, string id, Func<SourceQueryString, SourceQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_source".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SourceQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_source
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document; use `_all` to fetch the first document matching the ID across all types</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> GetSourceAsync(string index, string type, string id, Func<SourceQueryString, SourceQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_source".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SourceQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Index<T>(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndexAsync<T>(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Index(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndexAsync(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Index<T>(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndexAsync<T>(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Index(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndexAsync(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndexPut<T>(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndexPutAsync<T>(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndexPut(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndexPutAsync(string index, string type, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndexPut<T>(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/{id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndexPutAsync<T>(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/{id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndexPut(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/{id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-index_.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndexPutAsync(string index, string type, string id, object body, Func<IndexQueryString, IndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesAnalyzeGetForAll<T>(Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_analyze";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_analyze
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesAnalyzeGetForAllAsync<T>(Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_analyze";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesAnalyzeGetForAll(Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			var url = "_analyze";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_analyze
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesAnalyzeGetForAllAsync(Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			var url = "_analyze";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesAnalyzeGet<T>(string index, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_analyze
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesAnalyzeGetAsync<T>(string index, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesAnalyzeGet(string index, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_analyze
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesAnalyzeGetAsync(string index, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesAnalyzeForAll<T>(object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_analyze".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_analyze
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesAnalyzeForAllAsync<T>(object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_analyze".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesAnalyzeForAll(object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			var url = "_analyze".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_analyze
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesAnalyzeForAllAsync(object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			var url = "_analyze".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesAnalyze<T>(string index, object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_analyze
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesAnalyzeAsync<T>(string index, object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_analyze
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesAnalyze(string index, object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_analyze
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-analyze.html</para>	
	    ///</summary>
		///<param name="index">The name of the index to scope the operation</param>
		///<param name="body">The text on which the analysis should be performed</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesAnalyzeAsync(string index, object body, Func<AnalyzeQueryString, AnalyzeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_analyze".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AnalyzeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesClearCacheForAll<T>(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cache/clear
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesClearCacheForAllAsync<T>(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesClearCacheForAll(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cache/clear
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesClearCacheForAllAsync(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesClearCache<T>(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_cache/clear
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesClearCacheAsync<T>(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesClearCache(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_cache/clear
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesClearCacheAsync(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesClearCacheGetForAll<T>(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cache/clear
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesClearCacheGetForAllAsync<T>(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesClearCacheGetForAll(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cache/clear
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesClearCacheGetForAllAsync(Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			var url = "_cache/clear";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesClearCacheGet<T>(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_cache/clear
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesClearCacheGetAsync<T>(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_cache/clear
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesClearCacheGet(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_cache/clear
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-clearcache.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index name to limit the operation</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesClearCacheGetAsync(string index, Func<ClearCacheQueryString, ClearCacheQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_cache/clear".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ClearCacheQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_close
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesClose<T>(string index, Func<CloseIndexQueryString, CloseIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_close".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CloseIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_close
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesCloseAsync<T>(string index, Func<CloseIndexQueryString, CloseIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_close".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CloseIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_close
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesClose(string index, Func<CloseIndexQueryString, CloseIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_close".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CloseIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_close
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesCloseAsync(string index, Func<CloseIndexQueryString, CloseIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_close".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CloseIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesCreate<T>(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesCreateAsync<T>(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesCreate(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesCreateAsync(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesCreatePost<T>(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesCreatePostAsync<T>(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesCreatePost(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-create-index.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">The configuration for the index (`settings` and `mappings`)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesCreatePostAsync(string index, object body, Func<CreateIndexQueryString, CreateIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new CreateIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesDelete<T>(string index, Func<DeleteIndexQueryString, DeleteIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesDeleteAsync<T>(string index, Func<DeleteIndexQueryString, DeleteIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesDelete(string index, Func<DeleteIndexQueryString, DeleteIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-index.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesDeleteAsync(string index, Func<DeleteIndexQueryString, DeleteIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="name">A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesDeleteAlias<T>(string index, string name, Func<IndicesDeleteAliasQueryString, IndicesDeleteAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesDeleteAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="name">A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesDeleteAliasAsync<T>(string index, string name, Func<IndicesDeleteAliasQueryString, IndicesDeleteAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesDeleteAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="name">A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesDeleteAlias(string index, string name, Func<IndicesDeleteAliasQueryString, IndicesDeleteAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesDeleteAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="name">A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesDeleteAliasAsync(string index, string name, Func<IndicesDeleteAliasQueryString, IndicesDeleteAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesDeleteAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="type">A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesDeleteMapping<T>(string index, string type, Func<DeleteMappingQueryString, DeleteMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_mapping
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="type">A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesDeleteMappingAsync<T>(string index, string type, Func<DeleteMappingQueryString, DeleteMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="type">A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesDeleteMapping(string index, string type, Func<DeleteMappingQueryString, DeleteMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/{type}/_mapping
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-delete-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names (supports wildcards); use `_all` for all indices</param>
		///<param name="type">A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesDeleteMappingAsync(string index, string type, Func<DeleteMappingQueryString, DeleteMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesDeleteTemplateForAll<T>(string name, Func<DeleteTemplateQueryString, DeleteTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_template/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesDeleteTemplateForAllAsync<T>(string name, Func<DeleteTemplateQueryString, DeleteTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesDeleteTemplateForAll(string name, Func<DeleteTemplateQueryString, DeleteTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_template/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesDeleteTemplateForAllAsync(string name, Func<DeleteTemplateQueryString, DeleteTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</param>
		///<param name="name">A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesDeleteWarmer<T>(string index, string name, Func<DeleteWarmerQueryString, DeleteWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</param>
		///<param name="name">A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesDeleteWarmerAsync<T>(string index, string name, Func<DeleteWarmerQueryString, DeleteWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</param>
		///<param name="name">A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesDeleteWarmer(string index, string name, Func<DeleteWarmerQueryString, DeleteWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /{index}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</param>
		///<param name="name">A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesDeleteWarmerAsync(string index, string name, Func<DeleteWarmerQueryString, DeleteWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new DeleteWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExists<T>(string index, Func<IndexExistsQueryString, IndexExistsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsAsync<T>(string index, Func<IndexExistsQueryString, IndexExistsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExists(string index, Func<IndexExistsQueryString, IndexExistsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of indices to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsAsync(string index, Func<IndexExistsQueryString, IndexExistsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndexExistsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExistsAliasForAll<T>(string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsAliasForAllAsync<T>(string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExistsAliasForAll(string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsAliasForAllAsync(string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExistsAlias<T>(string index, string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsAliasAsync<T>(string index, string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExistsAlias(string index, string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsAliasAsync(string index, string name, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExistsAlias<T>(string index, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/_alias
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsAliasAsync<T>(string index, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExistsAlias(string index, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/_alias
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsAliasAsync(string index, Func<IndicesExistsAliasQueryString, IndicesExistsAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExistsTemplateForAll<T>(string name, Func<IndicesExistsTemplateQueryString, IndicesExistsTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /_template/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsTemplateForAllAsync<T>(string name, Func<IndicesExistsTemplateQueryString, IndicesExistsTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExistsTemplateForAll(string name, Func<IndicesExistsTemplateQueryString, IndicesExistsTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /_template/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsTemplateForAllAsync(string name, Func<IndicesExistsTemplateQueryString, IndicesExistsTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` to check the types across all indices</param>
		///<param name="type">A comma-separated list of document types to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesExistsType<T>(string index, string type, Func<IndicesExistsTypeQueryString, IndicesExistsTypeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTypeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` to check the types across all indices</param>
		///<param name="type">A comma-separated list of document types to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesExistsTypeAsync<T>(string index, string type, Func<IndicesExistsTypeQueryString, IndicesExistsTypeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTypeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /{index}/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` to check the types across all indices</param>
		///<param name="type">A comma-separated list of document types to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesExistsType(string index, string type, Func<IndicesExistsTypeQueryString, IndicesExistsTypeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTypeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /{index}/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-types-exists.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` to check the types across all indices</param>
		///<param name="type">A comma-separated list of document types to check</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesExistsTypeAsync(string index, string type, Func<IndicesExistsTypeQueryString, IndicesExistsTypeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesExistsTypeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesFlushForAll<T>(Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_flush
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesFlushForAllAsync<T>(Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesFlushForAll(Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_flush
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesFlushForAllAsync(Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesFlush<T>(string index, Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_flush
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesFlushAsync<T>(string index, Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesFlush(string index, Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_flush
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesFlushAsync(string index, Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesFlushGetForAll<T>(Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_flush
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesFlushGetForAllAsync<T>(Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesFlushGetForAll(Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_flush
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesFlushGetForAllAsync(Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			var url = "_flush";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesFlushGet<T>(string index, Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_flush
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesFlushGetAsync<T>(string index, Func<FlushQueryString, FlushQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_flush
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesFlushGet(string index, Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_flush
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-flush.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesFlushGetAsync(string index, Func<FlushQueryString, FlushQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_flush".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new FlushQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliasForAll<T>(Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_alias";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_alias
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasForAllAsync<T>(Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_alias";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliasForAll(Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			var url = "_alias";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_alias
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasForAllAsync(Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			var url = "_alias";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliasForAll<T>(string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasForAllAsync<T>(string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliasForAll(string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasForAllAsync(string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAlias<T>(string index, string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasAsync<T>(string index, string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAlias(string index, string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to return</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasAsync(string index, string name, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAlias<T>(string index, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_alias
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasAsync<T>(string index, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_alias
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAlias(string index, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_alias
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasAsync(string index, Func<GetAliasesQueryString, GetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_alias".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliasesForAll<T>(Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_aliases
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasesForAllAsync<T>(Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliasesForAll(Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			var url = "_aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_aliases
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasesForAllAsync(Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			var url = "_aliases";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliases<T>(string index, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_aliases".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_aliases
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasesAsync<T>(string index, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_aliases".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliases(string index, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_aliases".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_aliases
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasesAsync(string index, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_aliases".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliases<T>(string index, string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_aliases/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_aliases/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasesAsync<T>(string index, string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_aliases/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliases(string index, string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_aliases/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_aliases/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to filter aliases</param>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasesAsync(string index, string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_aliases/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetAliasesForAll<T>(string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_aliases/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetAliasesForAllAsync<T>(string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_aliases/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetAliasesForAll(string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_aliases/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">A comma-separated list of alias names to filter</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetAliasesForAllAsync(string name, Func<IndicesGetAliasesQueryString, IndicesGetAliasesQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_aliases/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetAliasesQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetFieldMappingForAll<T>(string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/field/{0}".F(Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/field/{field}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetFieldMappingForAllAsync<T>(string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/field/{0}".F(Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetFieldMappingForAll(string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/field/{0}".F(Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/field/{field}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetFieldMappingForAllAsync(string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/field/{0}".F(Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetFieldMapping<T>(string index, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/field/{1}".F(Encoded(index), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/field/{field}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetFieldMappingAsync<T>(string index, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/field/{1}".F(Encoded(index), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetFieldMapping(string index, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/field/{1}".F(Encoded(index), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/field/{field}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetFieldMappingAsync(string index, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/field/{1}".F(Encoded(index), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/{type}/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetFieldMappingForAll<T>(string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/{0}/field/{1}".F(Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/{type}/field/{field}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetFieldMappingForAllAsync<T>(string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/{0}/field/{1}".F(Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/{type}/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetFieldMappingForAll(string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/{0}/field/{1}".F(Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/{type}/field/{field}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetFieldMappingForAllAsync(string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "_mapping/{0}/field/{1}".F(Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetFieldMapping<T>(string index, string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/{1}/field/{2}".F(Encoded(index), Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}/field/{field}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetFieldMappingAsync<T>(string index, string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/{1}/field/{2}".F(Encoded(index), Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}/field/{field}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetFieldMapping(string index, string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/{1}/field/{2}".F(Encoded(index), Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}/field/{field}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-field-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="field">A comma-separated list of fields</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetFieldMappingAsync(string index, string type, string field, Func<IndicesGetFieldMappingQueryString, IndicesGetFieldMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			field.ThrowIfNullOrEmpty("field");
			var url = "{0}/_mapping/{1}/field/{2}".F(Encoded(index), Encoded(type), Encoded(field));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesGetFieldMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetMappingForAll<T>(Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mapping";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetMappingForAllAsync<T>(Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mapping";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetMappingForAll(Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			var url = "_mapping";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetMappingForAllAsync(Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			var url = "_mapping";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetMapping<T>(string index, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mapping".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetMappingAsync<T>(string index, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mapping".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetMapping(string index, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mapping".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetMappingAsync(string index, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mapping".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetMappingForAll<T>(string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetMappingForAllAsync<T>(string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetMappingForAll(string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mapping/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetMappingForAllAsync(string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetMapping<T>(string index, string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/_mapping/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetMappingAsync<T>(string index, string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/_mapping/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetMapping(string index, string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/_mapping/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mapping/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names</param>
		///<param name="type">A comma-separated list of document types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetMappingAsync(string index, string type, Func<GetMappingQueryString, GetMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/_mapping/{1}".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetSettingsForAll<T>(Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetSettingsForAllAsync<T>(Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetSettingsForAll(Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			var url = "_settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetSettingsForAllAsync(Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			var url = "_settings";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetSettings<T>(string index, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetSettingsAsync<T>(string index, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetSettings(string index, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetSettingsAsync(string index, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_settings/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetSettings<T>(string index, string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_settings/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_settings/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetSettingsAsync<T>(string index, string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_settings/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_settings/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetSettings(string index, string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_settings/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_settings/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetSettingsAsync(string index, string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_settings/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_settings/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetSettingsForAll<T>(string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_settings/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_settings/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetSettingsForAllAsync<T>(string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_settings/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_settings/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetSettingsForAll(string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_settings/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_settings/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-get-mapping.html</para>	
	    ///</summary>
		///<param name="name">The name of the settings that should be included</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetSettingsForAllAsync(string name, Func<GetIndexSettingsQueryString, GetIndexSettingsQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_settings/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetIndexSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_template
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetTemplateForAll<T>(Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_template";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_template
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetTemplateForAllAsync<T>(Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_template";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_template
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetTemplateForAll(Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null)
		{
			var url = "_template";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_template
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetTemplateForAllAsync(Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null)
		{
			var url = "_template";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetTemplateForAll<T>(string name, Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_template/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetTemplateForAllAsync<T>(string name, Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetTemplateForAll(string name, Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_template/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetTemplateForAllAsync(string name, Func<GetTemplateQueryString, GetTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_warmer
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetWarmerForAll<T>(Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_warmer";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_warmer
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetWarmerForAllAsync<T>(Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_warmer";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_warmer
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetWarmerForAll(Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			var url = "_warmer";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_warmer
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetWarmerForAllAsync(Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			var url = "_warmer";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_warmer
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetWarmer<T>(string index, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_warmer".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_warmer
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetWarmerAsync<T>(string index, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_warmer".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_warmer
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetWarmer(string index, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_warmer".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_warmer
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetWarmerAsync(string index, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_warmer".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetWarmer<T>(string index, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetWarmerAsync<T>(string index, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetWarmer(string index, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetWarmerAsync(string index, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetWarmerForAll<T>(string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetWarmerForAllAsync<T>(string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetWarmerForAll(string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetWarmerForAllAsync(string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesGetWarmer<T>(string index, string type, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesGetWarmerAsync<T>(string index, string type, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesGetWarmer(string index, string type, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer (supports wildcards); leave empty to get all warmers</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesGetWarmerAsync(string index, string type, string name, Func<GetWarmerQueryString, GetWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new GetWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_open
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesOpen<T>(string index, Func<OpenIndexQueryString, OpenIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_open".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OpenIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_open
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesOpenAsync<T>(string index, Func<OpenIndexQueryString, OpenIndexQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_open".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OpenIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_open
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesOpen(string index, Func<OpenIndexQueryString, OpenIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_open".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OpenIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_open
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-open-close.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesOpenAsync(string index, Func<OpenIndexQueryString, OpenIndexQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_open".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OpenIndexQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesOptimizeForAll<T>(Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_optimize
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesOptimizeForAllAsync<T>(Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesOptimizeForAll(Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_optimize
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesOptimizeForAllAsync(Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesOptimize<T>(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_optimize
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesOptimizeAsync<T>(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesOptimize(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_optimize
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesOptimizeAsync(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesOptimizeGetForAll<T>(Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_optimize
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesOptimizeGetForAllAsync<T>(Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesOptimizeGetForAll(Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_optimize
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesOptimizeGetForAllAsync(Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			var url = "_optimize";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesOptimizeGet<T>(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_optimize
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesOptimizeGetAsync<T>(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_optimize
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesOptimizeGet(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_optimize
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-optimize.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesOptimizeGetAsync(string index, Func<OptimizeQueryString, OptimizeQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_optimize".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new OptimizeQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutAlias<T>(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutAliasAsync<T>(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutAlias(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutAliasAsync(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutAliasForAll<T>(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutAliasForAllAsync<T>(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutAliasForAll(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutAliasForAllAsync(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutAliasPost<T>(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutAliasPostAsync<T>(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutAliasPost(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the alias should point to (supports wildcards); use `_all` or omit to perform the operation on all indices.</param>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutAliasPostAsync(string index, string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_alias/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutAliasPostForAll<T>(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_alias/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutAliasPostForAllAsync<T>(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_alias/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutAliasPostForAll(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_alias/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="name">The name of the alias to be created or updated</param>
		///<param name="body">The settings for the alias, such as `routing` or `filter`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutAliasPostForAllAsync(string name, object body, Func<IndicesPutAliasQueryString, IndicesPutAliasQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_alias/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesPutAliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutMapping<T>(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_mapping
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutMappingAsync<T>(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutMapping(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_mapping
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutMappingAsync(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutMappingForAll<T>(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_mapping/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutMappingForAllAsync<T>(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutMappingForAll(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_mapping/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutMappingForAllAsync(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutMappingPost<T>(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mapping
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutMappingPostAsync<T>(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mapping
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutMappingPost(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mapping
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</param>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutMappingPostAsync(string index, string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mapping".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutMappingPostForAll<T>(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mapping/{type}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutMappingPostForAllAsync<T>(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null, object deserializationState = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mapping/{type}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutMappingPostForAll(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mapping/{type}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-put-mapping.html</para>	
	    ///</summary>
		///<param name="type">The name of the document type</param>
		///<param name="body">The mapping definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutMappingPostForAllAsync(string type, object body, Func<PutMappingQueryString, PutMappingQueryString> queryString = null)
		{
			type.ThrowIfNullOrEmpty("type");
			var url = "_mapping/{0}".F(Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutMappingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutSettingsForAll<T>(object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutSettingsForAllAsync<T>(object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutSettingsForAll(object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null)
		{
			var url = "_settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutSettingsForAllAsync(object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null)
		{
			var url = "_settings".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutSettings<T>(string index, object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_settings
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutSettingsAsync<T>(string index, object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_settings
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutSettings(string index, object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_settings
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-update-settings.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The index settings to be updated</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutSettingsAsync(string index, object body, Func<UpdateSettingsQueryString, UpdateSettingsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_settings".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateSettingsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutTemplateForAll<T>(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_template/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutTemplateForAllAsync<T>(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutTemplateForAll(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_template/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutTemplateForAllAsync(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutTemplatePostForAll<T>(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_template/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutTemplatePostForAllAsync<T>(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_template/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutTemplatePostForAll(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_template/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-templates.html</para>	
	    ///</summary>
		///<param name="name">The name of the template</param>
		///<param name="body">The template definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutTemplatePostForAllAsync(string name, object body, Func<PutTemplateQueryString, PutTemplateQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_template/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutTemplateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmerForAll<T>(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerForAllAsync<T>(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmerForAll(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerForAllAsync(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmer<T>(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerAsync<T>(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmer(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerAsync(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmer<T>(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerAsync<T>(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmer(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerAsync(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmerPostForAll<T>(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerPostForAllAsync<T>(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmerPostForAll(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerPostForAllAsync(string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			name.ThrowIfNullOrEmpty("name");
			var url = "_warmer/{0}".F(Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmerPost<T>(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerPostAsync<T>(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmerPost(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerPostAsync(string index, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/_warmer/{1}".F(Encoded(index), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesPutWarmerPost<T>(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesPutWarmerPostAsync<T>(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesPutWarmerPost(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_warmer/{name}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-warmers.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</param>
		///<param name="name">The name of the warmer</param>
		///<param name="body">The search request definition for the warmer (query, filters, facets, sorting, etc)</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesPutWarmerPostAsync(string index, string type, string name, object body, Func<PutWarmerQueryString, PutWarmerQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			name.ThrowIfNullOrEmpty("name");
			var url = "{0}/{1}/_warmer/{2}".F(Encoded(index), Encoded(type), Encoded(name));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PutWarmerQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesRefreshForAll<T>(Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_refresh
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesRefreshForAllAsync<T>(Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesRefreshForAll(Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_refresh
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesRefreshForAllAsync(Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesRefresh<T>(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_refresh
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesRefreshAsync<T>(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesRefresh(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_refresh
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesRefreshAsync(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesRefreshGetForAll<T>(Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_refresh
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesRefreshGetForAllAsync<T>(Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesRefreshGetForAll(Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_refresh
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesRefreshGetForAllAsync(Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			var url = "_refresh";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesRefreshGet<T>(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_refresh
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesRefreshGetAsync<T>(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_refresh
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesRefreshGet(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_refresh
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-refresh.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesRefreshGetAsync(string index, Func<RefreshQueryString, RefreshQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_refresh".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new RefreshQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_segments
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesSegmentsForAll<T>(Func<SegmentsQueryString, SegmentsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_segments";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_segments
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesSegmentsForAllAsync<T>(Func<SegmentsQueryString, SegmentsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_segments";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_segments
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesSegmentsForAll(Func<SegmentsQueryString, SegmentsQueryString> queryString = null)
		{
			var url = "_segments";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_segments
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesSegmentsForAllAsync(Func<SegmentsQueryString, SegmentsQueryString> queryString = null)
		{
			var url = "_segments";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_segments
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesSegments<T>(string index, Func<SegmentsQueryString, SegmentsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_segments".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_segments
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesSegmentsAsync<T>(string index, Func<SegmentsQueryString, SegmentsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_segments".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_segments
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesSegments(string index, Func<SegmentsQueryString, SegmentsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_segments".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_segments
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-segments.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesSegmentsAsync(string index, Func<SegmentsQueryString, SegmentsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_segments".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SegmentsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_gateway/snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesSnapshotIndexForAll<T>(Func<SnapshotQueryString, SnapshotQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_gateway/snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_gateway/snapshot
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesSnapshotIndexForAllAsync<T>(Func<SnapshotQueryString, SnapshotQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_gateway/snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_gateway/snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesSnapshotIndexForAll(Func<SnapshotQueryString, SnapshotQueryString> queryString = null)
		{
			var url = "_gateway/snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_gateway/snapshot
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesSnapshotIndexForAllAsync(Func<SnapshotQueryString, SnapshotQueryString> queryString = null)
		{
			var url = "_gateway/snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_gateway/snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesSnapshotIndex<T>(string index, Func<SnapshotQueryString, SnapshotQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_gateway/snapshot".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_gateway/snapshot
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesSnapshotIndexAsync<T>(string index, Func<SnapshotQueryString, SnapshotQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_gateway/snapshot".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_gateway/snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesSnapshotIndex(string index, Func<SnapshotQueryString, SnapshotQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_gateway/snapshot".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_gateway/snapshot
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-gateway-snapshot.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string for all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesSnapshotIndexAsync(string index, Func<SnapshotQueryString, SnapshotQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_gateway/snapshot".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStatsForAll<T>(Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_stats
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatsForAllAsync<T>(Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStatsForAll(Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			var url = "_stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_stats
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatsForAllAsync(Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			var url = "_stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStatsForAll<T>(string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_stats/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatsForAllAsync<T>(string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStatsForAll(string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_stats/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatsForAllAsync(string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStats<T>(string index, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_stats".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_stats
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatsAsync<T>(string index, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_stats".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStats(string index, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_stats".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_stats
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatsAsync(string index, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_stats".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStats<T>(string index, string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "{0}/_stats/{1}".F(Encoded(index), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_stats/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatsAsync<T>(string index, string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "{0}/_stats/{1}".F(Encoded(index), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStats(string index, string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "{0}/_stats/{1}".F(Encoded(index), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_stats/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-stats.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="metric">Limit the information returned the specific metrics.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatsAsync(string index, string metric, Func<IndicesStatsQueryString, IndicesStatsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "{0}/_stats/{1}".F(Encoded(index), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_status
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStatusForAll<T>(Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_status";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_status
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatusForAllAsync<T>(Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_status";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_status
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStatusForAll(Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null)
		{
			var url = "_status";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_status
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatusForAllAsync(Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null)
		{
			var url = "_status";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_status
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesStatus<T>(string index, Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_status".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_status
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesStatusAsync<T>(string index, Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_status".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_status
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesStatus(string index, Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_status".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_status
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-status.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesStatusAsync(string index, Func<IndicesStatusQueryString, IndicesStatusQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_status".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new IndicesStatusQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="body">The definition of `actions` to perform</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesUpdateAliasesForAll<T>(object body, Func<AliasQueryString, AliasQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_aliases".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_aliases
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="body">The definition of `actions` to perform</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesUpdateAliasesForAllAsync<T>(object body, Func<AliasQueryString, AliasQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_aliases".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_aliases
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="body">The definition of `actions` to perform</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesUpdateAliasesForAll(object body, Func<AliasQueryString, AliasQueryString> queryString = null)
		{
			var url = "_aliases".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_aliases
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/indices-aliases.html</para>	
	    ///</summary>
		///<param name="body">The definition of `actions` to perform</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesUpdateAliasesForAllAsync(object body, Func<AliasQueryString, AliasQueryString> queryString = null)
		{
			var url = "_aliases".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new AliasQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQueryGetForAll<T>(Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_validate/query";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryGetForAllAsync<T>(Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_validate/query";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQueryGetForAll(Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			var url = "_validate/query";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryGetForAllAsync(Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			var url = "_validate/query";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQueryGet<T>(string index, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryGetAsync<T>(string index, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQueryGet(string index, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryGetAsync(string index, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQueryGet<T>(string index, string type, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryGetAsync<T>(string index, string type, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQueryGet(string index, string type, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryGetAsync(string index, string type, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQueryForAll<T>(object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_validate/query".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryForAllAsync<T>(object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_validate/query".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQueryForAll(object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			var url = "_validate/query".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryForAllAsync(object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			var url = "_validate/query".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQuery<T>(string index, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryAsync<T>(string index, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQuery(string index, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryAsync(string index, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_validate/query".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> IndicesValidateQuery<T>(string index, string type, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_validate/query
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> IndicesValidateQueryAsync<T>(string index, string type, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_validate/query
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> IndicesValidateQuery(string index, string type, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_validate/query
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-validate.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</param>
		///<param name="body">The query definition specified with the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> IndicesValidateQueryAsync(string index, string type, object body, Func<ValidateQueryQueryString, ValidateQueryQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_validate/query".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ValidateQueryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Info<T>(Func<InfoQueryString, InfoQueryString> queryString = null, object deserializationState = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new InfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> InfoAsync<T>(Func<InfoQueryString, InfoQueryString> queryString = null, object deserializationState = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new InfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Info(Func<InfoQueryString, InfoQueryString> queryString = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new InfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> InfoAsync(Func<InfoQueryString, InfoQueryString> queryString = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new InfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MgetGet<T>(Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mget";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetGetAsync<T>(Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mget";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MgetGet(Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			var url = "_mget";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetGetAsync(Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			var url = "_mget";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MgetGet<T>(string index, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetGetAsync<T>(string index, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MgetGet(string index, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetGetAsync(string index, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MgetGet<T>(string index, string type, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetGetAsync<T>(string index, string type, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MgetGet(string index, string type, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetGetAsync(string index, string type, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mget<T>(object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mget".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetAsync<T>(object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mget".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mget(object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			var url = "_mget".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetAsync(object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			var url = "_mget".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mget<T>(string index, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetAsync<T>(string index, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mget(string index, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetAsync(string index, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mget".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mget<T>(string index, string type, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mget
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MgetAsync<T>(string index, string type, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mget
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mget(string index, string type, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mget
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-get.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="body">Document identifiers; can be either `docs` (containing full document information) or `ids` (when index and type is provided in the URL.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MgetAsync(string index, string type, object body, Func<MultiGetQueryString, MultiGetQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mget".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MltGet<T>(string index, string type, string id, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MltGetAsync<T>(string index, string type, string id, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MltGet(string index, string type, string id, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MltGetAsync(string index, string type, string id, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="body">A specific search request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mlt<T>(string index, string type, string id, object body, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="body">A specific search request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MltAsync<T>(string index, string type, string id, object body, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="body">A specific search request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mlt(string index, string type, string id, object body, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_mlt
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-more-like-this.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document (use `_all` to fetch the first document matching the ID across all types)</param>
		///<param name="id">The document ID</param>
		///<param name="body">A specific search request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MltAsync(string index, string type, string id, object body, Func<MoreLikeThisQueryString, MoreLikeThisQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_mlt".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MoreLikeThisQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MpercolateGet<T>(Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mpercolate";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateGetAsync<T>(Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mpercolate";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MpercolateGet(Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			var url = "_mpercolate";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateGetAsync(Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			var url = "_mpercolate";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MpercolateGet<T>(string index, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateGetAsync<T>(string index, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MpercolateGet(string index, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateGetAsync(string index, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MpercolateGet<T>(string index, string type, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateGetAsync<T>(string index, string type, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MpercolateGet(string index, string type, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateGetAsync(string index, string type, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mpercolate<T>(object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mpercolate".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateAsync<T>(object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mpercolate".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mpercolate(object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			var url = "_mpercolate".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateAsync(object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			var url = "_mpercolate".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mpercolate<T>(string index, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateAsync<T>(string index, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mpercolate(string index, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateAsync(string index, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mpercolate".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mpercolate<T>(string index, string type, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mpercolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MpercolateAsync<T>(string index, string type, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mpercolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mpercolate(string index, string type, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mpercolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being count percolated to use as default</param>
		///<param name="type">The type of the document being percolated to use as default.</param>
		///<param name="body">The percolate request definitions (header &amp; body pair), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MpercolateAsync(string index, string type, object body, Func<MpercolateQueryString, MpercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mpercolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MpercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MsearchGet<T>(Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_msearch";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchGetAsync<T>(Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_msearch";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MsearchGet(Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			var url = "_msearch";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchGetAsync(Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			var url = "_msearch";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MsearchGet<T>(string index, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchGetAsync<T>(string index, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MsearchGet(string index, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchGetAsync(string index, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MsearchGet<T>(string index, string type, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchGetAsync<T>(string index, string type, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MsearchGet(string index, string type, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchGetAsync(string index, string type, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Msearch<T>(object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_msearch".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchAsync<T>(object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_msearch".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Msearch(object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			var url = "_msearch".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchAsync(object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			var url = "_msearch".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Msearch<T>(string index, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchAsync<T>(string index, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Msearch(string index, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchAsync(string index, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_msearch".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Msearch<T>(string index, string type, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_msearch
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MsearchAsync<T>(string index, string type, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_msearch
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Msearch(string index, string type, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_msearch
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-multi-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to use as default</param>
		///<param name="type">A comma-separated list of document types to use as default</param>
		///<param name="body">The request definitions (metadata-search request definition pairs), separated by newlines</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MsearchAsync(string index, string type, object body, Func<MultiSearchQueryString, MultiSearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_msearch".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MultiSearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MtermvectorsGet<T>(Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mtermvectors";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsGetAsync<T>(Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mtermvectors";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MtermvectorsGet(Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			var url = "_mtermvectors";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsGetAsync(Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			var url = "_mtermvectors";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MtermvectorsGet<T>(string index, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsGetAsync<T>(string index, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MtermvectorsGet(string index, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsGetAsync(string index, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> MtermvectorsGet<T>(string index, string type, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsGetAsync<T>(string index, string type, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> MtermvectorsGet(string index, string type, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsGetAsync(string index, string type, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mtermvectors<T>(object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mtermvectors".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsAsync<T>(object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_mtermvectors".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mtermvectors(object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			var url = "_mtermvectors".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsAsync(object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			var url = "_mtermvectors".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mtermvectors<T>(string index, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsAsync<T>(string index, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mtermvectors(string index, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsAsync(string index, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_mtermvectors".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Mtermvectors<T>(string index, string type, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mtermvectors
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> MtermvectorsAsync<T>(string index, string type, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mtermvectors
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Mtermvectors(string index, string type, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_mtermvectors
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-multi-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="body">Define ids, parameters or a list of parameters per document here. You must at least provide a list of document ids. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> MtermvectorsAsync(string index, string type, object body, Func<MtermvectorsQueryString, MtermvectorsQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_mtermvectors".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new MtermvectorsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/nodes/hotthreads
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesHotThreadsForAll<T>(Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/nodes/hotthreads";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/nodes/hotthreads
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesHotThreadsForAllAsync<T>(Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_cluster/nodes/hotthreads";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/nodes/hotthreads
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesHotThreadsForAll(Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null)
		{
			var url = "_cluster/nodes/hotthreads";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/nodes/hotthreads
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesHotThreadsForAllAsync(Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null)
		{
			var url = "_cluster/nodes/hotthreads";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/nodes/{node_id}/hotthreads
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesHotThreads<T>(string node_id, Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/hotthreads".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/nodes/{node_id}/hotthreads
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesHotThreadsAsync<T>(string node_id, Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/hotthreads".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_cluster/nodes/{node_id}/hotthreads
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesHotThreads(string node_id, Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/hotthreads".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_cluster/nodes/{node_id}/hotthreads
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-hot-threads.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesHotThreadsAsync(string node_id, Func<NodesHotThreadsQueryString, NodesHotThreadsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/hotthreads".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesHotThreadsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesInfoForAll<T>(Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesInfoForAllAsync<T>(Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesInfoForAll(Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			var url = "_nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesInfoForAllAsync(Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			var url = "_nodes";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesInfo<T>(string node_id, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesInfoAsync<T>(string node_id, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesInfo(string node_id, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesInfoAsync(string node_id, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesInfoForAll<T>(string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesInfoForAllAsync<T>(string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesInfoForAll(string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesInfoForAllAsync(string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesInfo<T>(string node_id, string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesInfoAsync<T>(string node_id, string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesInfo(string node_id, string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-info.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">A comma-separated list of metrics you wish returned. Leave empty to return all.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesInfoAsync(string node_id, string metric, Func<NodesInfoQueryString, NodesInfoQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesInfoQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_shutdown
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesShutdownForAll<T>(Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_shutdown";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_shutdown
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesShutdownForAllAsync<T>(Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_shutdown";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_shutdown
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesShutdownForAll(Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null)
		{
			var url = "_shutdown";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_shutdown
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesShutdownForAllAsync(Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null)
		{
			var url = "_shutdown";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cluster/nodes/{node_id}/_shutdown
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you&#39;re connected to, leave empty to perform the operation on all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesShutdown<T>(string node_id, Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/_shutdown".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cluster/nodes/{node_id}/_shutdown
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you&#39;re connected to, leave empty to perform the operation on all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesShutdownAsync<T>(string node_id, Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/_shutdown".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_cluster/nodes/{node_id}/_shutdown
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you&#39;re connected to, leave empty to perform the operation on all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesShutdown(string node_id, Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/_shutdown".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_cluster/nodes/{node_id}/_shutdown
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-shutdown.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you&#39;re connected to, leave empty to perform the operation on all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesShutdownAsync(string node_id, Func<NodesShutdownQueryString, NodesShutdownQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_cluster/nodes/{0}/_shutdown".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesShutdownQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStatsForAll<T>(Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_nodes/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsForAllAsync<T>(Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_nodes/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStatsForAll(Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			var url = "_nodes/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsForAllAsync(Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			var url = "_nodes/stats";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStats<T>(string node_id, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}/stats".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsAsync<T>(string node_id, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}/stats".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStats(string node_id, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}/stats".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsAsync(string node_id, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			var url = "_nodes/{0}/stats".F(Encoded(node_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStatsForAll<T>(string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsForAllAsync<T>(string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStatsForAll(string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsForAllAsync(string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/stats/{0}".F(Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStats<T>(string node_id, string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/stats/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsAsync<T>(string node_id, string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/stats/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStats(string node_id, string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/stats/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsAsync(string node_id, string metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			var url = "_nodes/{0}/stats/{1}".F(Encoded(node_id), Encoded(metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}/{index_metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStatsForAll<T>(string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/stats/{0}/{1}".F(Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}/{index_metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsForAllAsync<T>(string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/stats/{0}/{1}".F(Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}/{index_metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStatsForAll(string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/stats/{0}/{1}".F(Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/stats/{metric}/{index_metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsForAllAsync(string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/stats/{0}/{1}".F(Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}/{index_metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> NodesStats<T>(string node_id, string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/{0}/stats/{1}/{2}".F(Encoded(node_id), Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}/{index_metric}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> NodesStatsAsync<T>(string node_id, string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null, object deserializationState = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/{0}/stats/{1}/{2}".F(Encoded(node_id), Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}/{index_metric}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> NodesStats(string node_id, string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/{0}/stats/{1}/{2}".F(Encoded(node_id), Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_nodes/{node_id}/stats/{metric}/{index_metric}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/cluster-nodes-stats.html</para>	
	    ///</summary>
		///<param name="node_id">A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you&#39;re connecting to, leave empty to get information from all nodes</param>
		///<param name="metric">Limit the information returned to the specified metrics</param>
		///<param name="index_metric">Limit the information returned for `indices` metric to the specific index metrics. Isn&#39;t used if `indices` (or `all`) metric isn&#39;t specified.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> NodesStatsAsync(string node_id, string metric, string index_metric, Func<NodesStatsQueryString, NodesStatsQueryString> queryString = null)
		{
			node_id.ThrowIfNullOrEmpty("node_id");
			metric.ThrowIfNullOrEmpty("metric");
			index_metric.ThrowIfNullOrEmpty("index_metric");
			var url = "_nodes/{0}/stats/{1}/{2}".F(Encoded(node_id), Encoded(metric), Encoded(index_metric));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new NodesStatsQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> PercolateGet<T>(string index, string type, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> PercolateGetAsync<T>(string index, string type, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> PercolateGet(string index, string type, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_percolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> PercolateGetAsync(string index, string type, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> PercolateGet<T>(string index, string type, string id, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> PercolateGetAsync<T>(string index, string type, string id, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> PercolateGet(string index, string type, string id, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> PercolateGetAsync(string index, string type, string id, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Percolate<T>(string index, string type, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> PercolateAsync<T>(string index, string type, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Percolate(string index, string type, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_percolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> PercolateAsync(string index, string type, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_percolate".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Percolate<T>(string index, string type, string id, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> PercolateAsync<T>(string index, string type, string id, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Percolate(string index, string type, string id, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_percolate
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-percolate.html</para>	
	    ///</summary>
		///<param name="index">The index of the document being percolated.</param>
		///<param name="type">The type of the document being percolated.</param>
		///<param name="id">Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</param>
		///<param name="body">The percolator request definition using the percolate DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> PercolateAsync(string index, string type, string id, object body, Func<PercolateQueryString, PercolateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_percolate".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PercolateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Ping<T>(Func<PingQueryString, PingQueryString> queryString = null, object deserializationState = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> PingAsync<T>(Func<PingQueryString, PingQueryString> queryString = null, object deserializationState = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("HEAD", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a HEAD on /
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Ping(Func<PingQueryString, PingQueryString> queryString = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a HEAD on /
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> PingAsync(Func<PingQueryString, PingQueryString> queryString = null)
		{
			var url = "";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new PingQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("HEAD", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search/scroll
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ScrollGet<T>(Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search/scroll";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search/scroll
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ScrollGetAsync<T>(Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search/scroll";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search/scroll
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ScrollGet(Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			var url = "_search/scroll";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search/scroll
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ScrollGetAsync(Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			var url = "_search/scroll";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> ScrollGet<T>(string scroll_id, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search/scroll/{scroll_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ScrollGetAsync<T>(string scroll_id, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> ScrollGet(string scroll_id, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search/scroll/{scroll_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ScrollGetAsync(string scroll_id, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search/scroll
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Scroll<T>(object body, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search/scroll".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search/scroll
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ScrollAsync<T>(object body, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search/scroll".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search/scroll
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Scroll(object body, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			var url = "_search/scroll".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search/scroll
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ScrollAsync(object body, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			var url = "_search/scroll".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Scroll<T>(string scroll_id, object body, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search/scroll/{scroll_id}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> ScrollAsync<T>(string scroll_id, object body, Func<ScrollQueryString, ScrollQueryString> queryString = null, object deserializationState = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search/scroll/{scroll_id}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Scroll(string scroll_id, object body, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search/scroll/{scroll_id}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-request-scroll.html</para>	
	    ///</summary>
		///<param name="scroll_id">The scroll ID</param>
		///<param name="body">The scroll ID if not passed by URL or query parameter.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> ScrollAsync(string scroll_id, object body, Func<ScrollQueryString, ScrollQueryString> queryString = null)
		{
			scroll_id.ThrowIfNullOrEmpty("scroll_id");
			var url = "_search/scroll/{0}".F(Encoded(scroll_id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new ScrollQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SearchGet<T>(Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchGetAsync<T>(Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SearchGet(Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			var url = "_search";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchGetAsync(Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			var url = "_search";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SearchGet<T>(string index, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchGetAsync<T>(string index, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SearchGet(string index, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchGetAsync(string index, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SearchGet<T>(string index, string type, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchGetAsync<T>(string index, string type, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SearchGet(string index, string type, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchGetAsync(string index, string type, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Search<T>(object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchAsync<T>(object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_search".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Search(object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			var url = "_search".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchAsync(object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			var url = "_search".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Search<T>(string index, object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchAsync<T>(string index, object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Search(string index, object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchAsync(string index, object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_search".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Search<T>(string index, string type, object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_search
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SearchAsync<T>(string index, string type, object body, Func<SearchQueryString, SearchQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/_search
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Search(string index, string type, object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/_search
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="type">A comma-separated list of document types to search; leave empty to perform the operation on all types</param>
		///<param name="body">The search definition using the Query DSL</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SearchAsync(string index, string type, object body, Func<SearchQueryString, SearchQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			var url = "{0}/{1}/_search".F(Encoded(index), Encoded(type));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SearchQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotCreate<T>(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotCreateAsync<T>(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotCreate(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotCreateAsync(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotCreatePost<T>(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotCreatePostAsync<T>(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotCreatePost(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">The snapshot definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotCreatePostAsync(string repository, string snapshot, object body, Func<SnapshotCreateQueryString, SnapshotCreateQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotCreateRepository<T>(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotCreateRepositoryAsync<T>(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("PUT", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotCreateRepository(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a PUT on /_snapshot/{repository}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotCreateRepositoryAsync(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("PUT", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotCreateRepositoryPost<T>(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotCreateRepositoryPostAsync<T>(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotCreateRepositoryPost(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="body">The repository definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotCreateRepositoryPostAsync(string repository, object body, Func<SnapshotCreateRepositoryQueryString, SnapshotCreateRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotCreateRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotDelete<T>(string repository, string snapshot, Func<SnapshotDeleteQueryString, SnapshotDeleteQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotDeleteAsync<T>(string repository, string snapshot, Func<SnapshotDeleteQueryString, SnapshotDeleteQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotDelete(string repository, string snapshot, Func<SnapshotDeleteQueryString, SnapshotDeleteQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotDeleteAsync(string repository, string snapshot, Func<SnapshotDeleteQueryString, SnapshotDeleteQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotDeleteRepository<T>(string repository, Func<SnapshotDeleteRepositoryQueryString, SnapshotDeleteRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotDeleteRepositoryAsync<T>(string repository, Func<SnapshotDeleteRepositoryQueryString, SnapshotDeleteRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("DELETE", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotDeleteRepository(string repository, Func<SnapshotDeleteRepositoryQueryString, SnapshotDeleteRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a DELETE on /_snapshot/{repository}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotDeleteRepositoryAsync(string repository, Func<SnapshotDeleteRepositoryQueryString, SnapshotDeleteRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotDeleteRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("DELETE", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A comma-separated list of snapshot names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotGet<T>(string repository, string snapshot, Func<SnapshotGetQueryString, SnapshotGetQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A comma-separated list of snapshot names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotGetAsync<T>(string repository, string snapshot, Func<SnapshotGetQueryString, SnapshotGetQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A comma-separated list of snapshot names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotGet(string repository, string snapshot, Func<SnapshotGetQueryString, SnapshotGetQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}/{snapshot}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A comma-separated list of snapshot names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotGetAsync(string repository, string snapshot, Func<SnapshotGetQueryString, SnapshotGetQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotGetRepository<T>(Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotGetRepositoryAsync<T>(Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotGetRepository(Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null)
		{
			var url = "_snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotGetRepositoryAsync(Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null)
		{
			var url = "_snapshot";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotGetRepository<T>(string repository, Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotGetRepositoryAsync<T>(string repository, Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotGetRepository(string repository, Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_snapshot/{repository}
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A comma-separated list of repository names</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotGetRepositoryAsync(string repository, Func<SnapshotGetRepositoryQueryString, SnapshotGetRepositoryQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			var url = "_snapshot/{0}".F(Encoded(repository));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotGetRepositoryQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}/_restore
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">Details of what to restore</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SnapshotRestore<T>(string repository, string snapshot, object body, Func<SnapshotRestoreQueryString, SnapshotRestoreQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}/_restore".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotRestoreQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}/_restore
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">Details of what to restore</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SnapshotRestoreAsync<T>(string repository, string snapshot, object body, Func<SnapshotRestoreQueryString, SnapshotRestoreQueryString> queryString = null, object deserializationState = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}/_restore".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotRestoreQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}/_restore
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">Details of what to restore</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SnapshotRestore(string repository, string snapshot, object body, Func<SnapshotRestoreQueryString, SnapshotRestoreQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}/_restore".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotRestoreQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_snapshot/{repository}/{snapshot}/_restore
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/modules-snapshots.html</para>	
	    ///</summary>
		///<param name="repository">A repository name</param>
		///<param name="snapshot">A snapshot name</param>
		///<param name="body">Details of what to restore</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SnapshotRestoreAsync(string repository, string snapshot, object body, Func<SnapshotRestoreQueryString, SnapshotRestoreQueryString> queryString = null)
		{
			repository.ThrowIfNullOrEmpty("repository");
			snapshot.ThrowIfNullOrEmpty("snapshot");
			var url = "_snapshot/{0}/{1}/_restore".F(Encoded(repository), Encoded(snapshot));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SnapshotRestoreQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Suggest<T>(object body, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_suggest".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_suggest
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SuggestAsync<T>(object body, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_suggest".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Suggest(object body, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			var url = "_suggest".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /_suggest
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SuggestAsync(object body, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			var url = "_suggest".F();
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Suggest<T>(string index, object body, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_suggest
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SuggestAsync<T>(string index, object body, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Suggest(string index, object body, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/_suggest
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="body">The request definition</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SuggestAsync(string index, object body, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SuggestGet<T>(Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_suggest";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_suggest
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SuggestGetAsync<T>(Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			var url = "_suggest";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SuggestGet(Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			var url = "_suggest";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /_suggest
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SuggestGetAsync(Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			var url = "_suggest";
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> SuggestGet<T>(string index, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_suggest
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> SuggestGetAsync<T>(string index, Func<SuggestQueryString, SuggestQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/_suggest
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> SuggestGet(string index, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/_suggest
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/search-search.html</para>	
	    ///</summary>
		///<param name="index">A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> SuggestGetAsync(string index, Func<SuggestQueryString, SuggestQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			var url = "{0}/_suggest".F(Encoded(index));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new SuggestQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> TermvectorGet<T>(string index, string type, string id, Func<TermvectorQueryString, TermvectorQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> TermvectorGetAsync<T>(string index, string type, string id, Func<TermvectorQueryString, TermvectorQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("GET", url, data: null, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> TermvectorGet(string index, string type, string id, Func<TermvectorQueryString, TermvectorQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a GET on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> TermvectorGetAsync(string index, string type, string id, Func<TermvectorQueryString, TermvectorQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("GET", url, data: null, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="body">Define parameters. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Termvector<T>(string index, string type, string id, object body, Func<TermvectorQueryString, TermvectorQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="body">Define parameters. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> TermvectorAsync<T>(string index, string type, string id, object body, Func<TermvectorQueryString, TermvectorQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="body">Define parameters. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Termvector(string index, string type, string id, object body, Func<TermvectorQueryString, TermvectorQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_termvector
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-termvectors.html</para>	
	    ///</summary>
		///<param name="index">The index in which the document resides.</param>
		///<param name="type">The type of the document.</param>
		///<param name="id">The id of the document.</param>
		///<param name="body">Define parameters. See documentation.</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> TermvectorAsync(string index, string type, string id, object body, Func<TermvectorQueryString, TermvectorQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_termvector".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new TermvectorQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_update
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The request definition using either `script` or partial `doc`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public ElasticsearchResponse<T> Update<T>(string index, string type, string id, object body, Func<UpdateQueryString, UpdateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_update".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequest<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_update
		///<para></para>Returns: A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The request definition using either `script` or partial `doc`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<param name="deserializationState">Optional state that will be passed to the deserialization call for the response</param>
		///<returns>A task that'll return an ElasticsearchResponse&lt;T&gt; holding the reponse body deserialized as T.
		///<para> - If T is of type byte[] deserialization will be shortcircuited</para>
		///<para> - If T is of type VoidResponse the response stream will be ignored completely</para>
		///</returns>
		public Task<ElasticsearchResponse<T>> UpdateAsync<T>(string index, string type, string id, object body, Func<UpdateQueryString, UpdateQueryString> queryString = null, object deserializationState = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_update".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return this.DoRequestAsync<T>("POST", url, body, 
				queryString: nv
				, deserializationState: deserializationState
			);
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_update
		///<para></para>Returns: ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The request definition using either `script` or partial `doc`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>ElasticsearchResponse&lt;T&gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public ElasticsearchResponse<DynamicDictionary> Update(string index, string type, string id, object body, Func<UpdateQueryString, UpdateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_update".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.Wrap(this.DoRequest<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
		
		///<summary>Represents a POST on /{index}/{type}/{id}/_update
		///<para></para>Returns: Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
	    ///<para>See also: http://www.elasticsearch.org/guide/en/elasticsearch/reference/1.x/docs-update.html</para>	
	    ///</summary>
		///<param name="index">The name of the index</param>
		///<param name="type">The type of the document</param>
		///<param name="id">Document ID</param>
		///<param name="body">The request definition using either `script` or partial `doc`</param>
		///<param name="queryString">Optional function to specify any additional querystring parameters for the request.</param>
		///<returns>Task that'll return an ElasticsearchResponse&lt;T$gt; holding the response body deserialized as DynamicDictionary
		///<para> - Dynamic dictionary is a special dynamic type that allows json to be traversed safely</para>
		///<para> - i.e result.Response.hits.hits[0].property.nested["nested_deeper"]</para>
		///<para> - can be safely dispatched to a nullable type even if intermediate properties do not exist</para>
		///</returns>
		public Task<ElasticsearchResponse<DynamicDictionary>> UpdateAsync(string index, string type, string id, object body, Func<UpdateQueryString, UpdateQueryString> queryString = null)
		{
			index.ThrowIfNullOrEmpty("index");
			type.ThrowIfNullOrEmpty("type");
			id.ThrowIfNullOrEmpty("id");
			var url = "{0}/{1}/{2}/_update".F(Encoded(index), Encoded(type), Encoded(id));
			NameValueCollection nv = null;
			if (queryString != null)
			{
				var qs = queryString(new UpdateQueryString());
				if (qs != null) nv = this.ToNameValueCollection(qs);
			}

			return ElasticsearchResponse.WrapAsync(this.DoRequestAsync<Dictionary<string, object>>("POST", url, body, 
				queryString: nv
			));
		}
	
	  }
	  }
	
